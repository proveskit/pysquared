{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"PySquared","text":"<p>PySquared is a CircuitPython-based CubeSat flight software library with flight heritage. It provides robust, modular components for spacecraft control, telemetry, configuration, and hardware management.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Modular architecture for easy extension and customization</li> <li>Type-checked protocols and sensor interfaces</li> <li>Robust error handling and JSON-structured logging</li> <li>Configuration management with validation</li> <li>High test coverage</li> <li>Designed for microcontroller resource constraints</li> </ul>"},{"location":"#quick-start","title":"Quick Start","text":""},{"location":"#using-pysquared-for-your-satellite","title":"Using PySquared for your Satellite","text":"<p>If you are looking to use PySquared in your own project, see the Getting Started guide.</p>"},{"location":"#contributing-to-pysquared","title":"Contributing to PySquared","text":"<p>If you want to contribute to PySquared, follow these steps:</p> <ol> <li> <p>Clone the repository:    <pre><code>git clone https://github.com/proveskit/pysquared.git\ncd pysquared\n</code></pre></p> </li> <li> <p>Install dependencies using <code>uv</code>:    <pre><code>make\n</code></pre></p> </li> <li> <p>Run tests:    <pre><code>make test\n</code></pre></p> </li> <li> <p>See the contributing guide for more details.</p> </li> </ol>"},{"location":"#documentation","title":"Documentation","text":"<ul> <li>Getting Started</li> <li>Frozen Modules - Build custom CircuitPython firmware</li> <li>Design Guide</li> <li>Configuration</li> <li>Error Handling &amp; Logging</li> <li>API Reference</li> <li>Contributing</li> </ul>"},{"location":"#supported-platforms","title":"Supported Platforms","text":"<ul> <li>PROVES Kit hardware</li> <li>Devices supported by CircuitPython</li> </ul>"},{"location":"#contributing","title":"Contributing","text":"<p>We welcome contributions! Please read our contributing guide and design guide before submitting changes. If you have questions, open an issue or discussion.</p>"},{"location":"api/","title":"API reference","text":""},{"location":"api/#pysquared","title":"pysquared","text":"<p>PySquared Satellite Flight Software</p> <p>Modules:</p> <ul> <li> <code>beacon</code>           \u2013            <p>This module provides a Beacon class for sending periodic status messages.</p> </li> <li> <code>binary_encoder</code>           \u2013            <p>Binary encoding utilities for efficient packet transmission.</p> </li> <li> <code>boot</code>           \u2013            <p>This module provides utilities that can run during the boot process by adding them to boot.py.</p> </li> <li> <code>cdh</code>           \u2013            <p>This module provides the CommandDataHandler for managing and processing commands.</p> </li> <li> <code>config</code>           \u2013            <p>This module provides an interface for managing configuration settings in the PySquared project.</p> </li> <li> <code>detumble</code>           \u2013            <p>This module provides functions for satellite detumbling using magnetorquers.</p> </li> <li> <code>file_validation</code>           \u2013            <p>File validation package for PySquared.</p> </li> <li> <code>hardware</code>           \u2013            <p>This module provides managers for various hardware components including sensors, actuators, communication interfaces, etc.</p> </li> <li> <code>logger</code>           \u2013            <p>This module provides a Logger class for handling logging messages.</p> </li> <li> <code>nvm</code>           \u2013            <p>The NVM package is a collection of functionality that interacts with non-volatile memory</p> </li> <li> <code>power_health</code>           \u2013            <p>This module provides a PowerHealth class for monitoring the power system.</p> </li> <li> <code>protos</code>           \u2013            <p>This module defines hardware agnostic protocols for accessing devices with certain features.</p> </li> <li> <code>rtc</code>           \u2013            <p>This module provides Real-Time Clock (RTC) management functionality for the PySquared satellite.</p> </li> <li> <code>sensor_reading</code>           \u2013            <p>Module for sensor reading definitions.</p> </li> <li> <code>sleep_helper</code>           \u2013            <p>This module provides the SleepHelper class for managing safe sleep and hibernation</p> </li> <li> <code>watchdog</code>           \u2013            <p>This module provides the Watchdog class for managing the hardware watchdog timer</p> </li> </ul>"},{"location":"api/#pysquared.beacon","title":"beacon","text":"<p>This module provides a Beacon class for sending periodic status messages.</p> <p>The Beacon class collects data from various sensors and system components, formats it as a JSON string, and sends it using a provided packet manager. This is typically used for sending telemetry or health information from a satellite or remote device.</p> <p>Usage: <pre><code>logger = Logger()\npacket_manager = PacketManager(logger, radio)\nboot_time = time.time()\nbeacon = Beacon(logger, \"MySat\", packet_manager, boot_time, imu, power_monitor)\nbeacon.send()\n</code></pre></p> <p>Classes:</p> <ul> <li> <code>Beacon</code>           \u2013            <p>A beacon for sending status messages.</p> </li> </ul>"},{"location":"api/#pysquared.beacon.Beacon","title":"Beacon","text":"<pre><code>Beacon(logger: Logger, name: str, packet_manager: PacketManager, boot_time: float, *args: PowerMonitorProto | RadioProto | IMUProto | MagnetometerProto | TemperatureSensorProto | Flag | Counter | Processor)\n</code></pre> <p>A beacon for sending status messages.</p> <p>Parameters:</p> <p>Methods:</p> <ul> <li> <code>decode_binary_beacon</code>             \u2013              <p>Decode binary beacon data received from another satellite.</p> </li> <li> <code>generate_key_mapping</code>             \u2013              <p>Create a key mapping for this beacon's data structure.</p> </li> <li> <code>send</code>             \u2013              <p>Sends the beacon.</p> </li> <li> <code>send_json</code>             \u2013              <p>Sends the beacon using JSON encoding (legacy method).</p> </li> </ul>"},{"location":"api/#pysquared.beacon.Beacon(logger)","title":"<code>logger</code>","text":"(<code>Logger</code>)           \u2013            <p>The logger to use.</p>"},{"location":"api/#pysquared.beacon.Beacon(name)","title":"<code>name</code>","text":"(<code>str</code>)           \u2013            <p>The name of the beacon.</p>"},{"location":"api/#pysquared.beacon.Beacon(packet_manager)","title":"<code>packet_manager</code>","text":"(<code>PacketManager</code>)           \u2013            <p>The packet manager to use for sending the beacon.</p>"},{"location":"api/#pysquared.beacon.Beacon(boot_time)","title":"<code>boot_time</code>","text":"(<code>float</code>)           \u2013            <p>The time the system booted.</p>"},{"location":"api/#pysquared.beacon.Beacon(*args)","title":"<code>*args</code>","text":"(<code>PowerMonitorProto | RadioProto | IMUProto | MagnetometerProto | TemperatureSensorProto | Flag | Counter | Processor</code>, default:                   <code>()</code> )           \u2013            <p>A list of sensors and other components to include in the beacon.</p>"},{"location":"api/#pysquared.beacon.Beacon.decode_binary_beacon","title":"decode_binary_beacon  <code>staticmethod</code>","text":"<pre><code>decode_binary_beacon(data: bytes, key_map: dict | None = None) -&gt; dict\n</code></pre> <p>Decode binary beacon data received from another satellite.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>dict</code>           \u2013            <p>Dictionary containing decoded beacon data</p> </li> </ul>"},{"location":"api/#pysquared.beacon.Beacon.decode_binary_beacon(data)","title":"<code>data</code>","text":"(<code>bytes</code>)           \u2013            <p>Binary encoded beacon data</p>"},{"location":"api/#pysquared.beacon.Beacon.decode_binary_beacon(key_map)","title":"<code>key_map</code>","text":"(<code>dict | None</code>, default:                   <code>None</code> )           \u2013            <p>Optional key mapping for decoding (hash -&gt; key name)</p>"},{"location":"api/#pysquared.beacon.Beacon.generate_key_mapping","title":"generate_key_mapping","text":"<pre><code>generate_key_mapping() -&gt; dict\n</code></pre> <p>Create a key mapping for this beacon's data structure.</p> <p>This method generates a template beacon packet and returns the key mapping that can be used to decode binary beacon data with the same structure.</p> <p>Returns:</p> <ul> <li> <code>dict</code>           \u2013            <p>Dictionary mapping key hashes to key names</p> </li> </ul>"},{"location":"api/#pysquared.beacon.Beacon.send","title":"send","text":"<pre><code>send() -&gt; bool\n</code></pre> <p>Sends the beacon.</p> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>True if the beacon was sent successfully, False otherwise.</p> </li> </ul>"},{"location":"api/#pysquared.beacon.Beacon.send_json","title":"send_json","text":"<pre><code>send_json() -&gt; bool\n</code></pre> <p>Sends the beacon using JSON encoding (legacy method).</p> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>True if the beacon was sent successfully, False otherwise.</p> </li> </ul>"},{"location":"api/#pysquared.binary_encoder","title":"binary_encoder","text":"<p>Binary encoding utilities for efficient packet transmission.</p> <p>This module provides functions to encode and decode int and float values directly into byte arrays instead of string representations, significantly reducing packet size and improving transmission efficiency.</p> <p>Usage: <pre><code>encoder = BinaryEncoder()\nencoder.add_float(\"temperature\", 23.5)\nencoder.add_int(\"battery_level\", 85)\ndata = encoder.to_bytes()\n\ndecoder = BinaryDecoder(data)\ntemperature = decoder.get_float(\"temperature\")\nbattery_level = decoder.get_int(\"battery_level\")\n</code></pre></p> <p>Classes:</p> <ul> <li> <code>BinaryDecoder</code>           \u2013            <p>Decodes data from binary format.</p> </li> <li> <code>BinaryEncoder</code>           \u2013            <p>Encodes data into a compact binary format.</p> </li> </ul>"},{"location":"api/#pysquared.binary_encoder.BinaryDecoder","title":"BinaryDecoder","text":"<pre><code>BinaryDecoder(data: bytes, key_map: Optional[Dict[int, str]] = None)\n</code></pre> <p>Decodes data from binary format.</p> <p>Parameters:</p> <p>Methods:</p> <ul> <li> <code>get_all</code>             \u2013              <p>Get all decoded data.</p> </li> <li> <code>get_float</code>             \u2013              <p>Get a float value.</p> </li> <li> <code>get_int</code>             \u2013              <p>Get an integer value.</p> </li> <li> <code>get_string</code>             \u2013              <p>Get a string value.</p> </li> </ul>"},{"location":"api/#pysquared.binary_encoder.BinaryDecoder(data)","title":"<code>data</code>","text":"(<code>bytes</code>)           \u2013            <p>The binary data to decode</p>"},{"location":"api/#pysquared.binary_encoder.BinaryDecoder(key_map)","title":"<code>key_map</code>","text":"(<code>Optional[Dict[int, str]]</code>, default:                   <code>None</code> )           \u2013            <p>Optional mapping from hash to key name</p>"},{"location":"api/#pysquared.binary_encoder.BinaryDecoder.get_all","title":"get_all","text":"<pre><code>get_all() -&gt; Dict[str, Union[int, float, str]]\n</code></pre> <p>Get all decoded data.</p> <p>Returns:</p> <ul> <li> <code>Dict[str, Union[int, float, str]]</code>           \u2013            <p>Dictionary containing all decoded key-value pairs</p> </li> </ul>"},{"location":"api/#pysquared.binary_encoder.BinaryDecoder.get_float","title":"get_float","text":"<pre><code>get_float(key: str) -&gt; Optional[float]\n</code></pre> <p>Get a float value.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Optional[float]</code>           \u2013            <p>The float value or None if not found</p> </li> </ul>"},{"location":"api/#pysquared.binary_encoder.BinaryDecoder.get_float(key)","title":"<code>key</code>","text":"(<code>str</code>)           \u2013            <p>The key name</p>"},{"location":"api/#pysquared.binary_encoder.BinaryDecoder.get_int","title":"get_int","text":"<pre><code>get_int(key: str) -&gt; Optional[int]\n</code></pre> <p>Get an integer value.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Optional[int]</code>           \u2013            <p>The integer value or None if not found</p> </li> </ul>"},{"location":"api/#pysquared.binary_encoder.BinaryDecoder.get_int(key)","title":"<code>key</code>","text":"(<code>str</code>)           \u2013            <p>The key name</p>"},{"location":"api/#pysquared.binary_encoder.BinaryDecoder.get_string","title":"get_string","text":"<pre><code>get_string(key: str) -&gt; Optional[str]\n</code></pre> <p>Get a string value.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Optional[str]</code>           \u2013            <p>The string value or None if not found</p> </li> </ul>"},{"location":"api/#pysquared.binary_encoder.BinaryDecoder.get_string(key)","title":"<code>key</code>","text":"(<code>str</code>)           \u2013            <p>The key name</p>"},{"location":"api/#pysquared.binary_encoder.BinaryEncoder","title":"BinaryEncoder","text":"<pre><code>BinaryEncoder()\n</code></pre> <p>Encodes data into a compact binary format.</p> <p>Methods:</p> <ul> <li> <code>add_float</code>             \u2013              <p>Add a float value.</p> </li> <li> <code>add_int</code>             \u2013              <p>Add an integer value.</p> </li> <li> <code>add_string</code>             \u2013              <p>Add a string value with length prefix.</p> </li> <li> <code>get_key_map</code>             \u2013              <p>Get the key mapping for decoding.</p> </li> <li> <code>to_bytes</code>             \u2013              <p>Convert the encoded data to bytes using a compact format.</p> </li> </ul>"},{"location":"api/#pysquared.binary_encoder.BinaryEncoder.add_float","title":"add_float","text":"<pre><code>add_float(key: str, value: float, double_precision: bool = False) -&gt; None\n</code></pre> <p>Add a float value.</p> <p>Parameters:</p>"},{"location":"api/#pysquared.binary_encoder.BinaryEncoder.add_float(key)","title":"<code>key</code>","text":"(<code>str</code>)           \u2013            <p>The key name for the value</p>"},{"location":"api/#pysquared.binary_encoder.BinaryEncoder.add_float(value)","title":"<code>value</code>","text":"(<code>float</code>)           \u2013            <p>The float value</p>"},{"location":"api/#pysquared.binary_encoder.BinaryEncoder.add_float(double_precision)","title":"<code>double_precision</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Use double precision (8 bytes) instead of single (4 bytes)</p>"},{"location":"api/#pysquared.binary_encoder.BinaryEncoder.add_int","title":"add_int","text":"<pre><code>add_int(key: str, value: int, size: int | None = None) -&gt; None\n</code></pre> <p>Add an integer value.</p> <p>Parameters:</p>"},{"location":"api/#pysquared.binary_encoder.BinaryEncoder.add_int(key)","title":"<code>key</code>","text":"(<code>str</code>)           \u2013            <p>The key name for the value</p>"},{"location":"api/#pysquared.binary_encoder.BinaryEncoder.add_int(value)","title":"<code>value</code>","text":"(<code>int</code>)           \u2013            <p>The integer value</p>"},{"location":"api/#pysquared.binary_encoder.BinaryEncoder.add_int(size)","title":"<code>size</code>","text":"(<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>Size in bytes (1, 2, 4, or 8). If None, automatically determined based on value range.</p>"},{"location":"api/#pysquared.binary_encoder.BinaryEncoder.add_string","title":"add_string","text":"<pre><code>add_string(key: str, value: str, max_length: int = 255) -&gt; None\n</code></pre> <p>Add a string value with length prefix.</p> <p>Parameters:</p>"},{"location":"api/#pysquared.binary_encoder.BinaryEncoder.add_string(key)","title":"<code>key</code>","text":"(<code>str</code>)           \u2013            <p>The key name for the value</p>"},{"location":"api/#pysquared.binary_encoder.BinaryEncoder.add_string(value)","title":"<code>value</code>","text":"(<code>str</code>)           \u2013            <p>The string value</p>"},{"location":"api/#pysquared.binary_encoder.BinaryEncoder.add_string(max_length)","title":"<code>max_length</code>","text":"(<code>int</code>, default:                   <code>255</code> )           \u2013            <p>Maximum string length</p>"},{"location":"api/#pysquared.binary_encoder.BinaryEncoder.get_key_map","title":"get_key_map","text":"<pre><code>get_key_map() -&gt; Dict[int, str]\n</code></pre> <p>Get the key mapping for decoding.</p> <p>Returns:</p> <ul> <li> <code>Dict[int, str]</code>           \u2013            <p>Dictionary mapping key hashes to key names</p> </li> </ul>"},{"location":"api/#pysquared.binary_encoder.BinaryEncoder.to_bytes","title":"to_bytes","text":"<pre><code>to_bytes() -&gt; bytes\n</code></pre> <p>Convert the encoded data to bytes using a compact format.</p> <p>Format: [key_hash:4][type:1][data:variable]...</p> <p>Returns:</p> <ul> <li> <code>bytes</code>           \u2013            <p>The binary representation of all added data</p> </li> </ul>"},{"location":"api/#pysquared.boot","title":"boot","text":"<p>This module provides utilities that can run during the boot process by adding them to boot.py.</p> <p>Modules:</p> <ul> <li> <code>filesystem</code>           \u2013            <p>File includes utilities for managing the filesystem during the boot process.</p> </li> </ul>"},{"location":"api/#pysquared.boot.filesystem","title":"filesystem","text":"<p>File includes utilities for managing the filesystem during the boot process.</p> <p>Functions:</p> <ul> <li> <code>mkdir</code>             \u2013              <p>Create directories on internal storage during boot.</p> </li> </ul>"},{"location":"api/#pysquared.boot.filesystem.mkdir","title":"mkdir","text":"<pre><code>mkdir(path: str, storage_action_delay: float = 0.02) -&gt; None\n</code></pre> <p>Create directories on internal storage during boot.</p> <p>In CircuitPython the internal storage is not writable by default. In order to mount any external storage (such as an SD Card) the drive must be remounted in read/write mode. This function handles the necessary steps to safely create a directory on the internal storage during boot.</p> <p>Parameters:</p> Usage <pre><code>from pysquared.boot.filesystem import mkdir\nmkdir(\"/sd\")\n</code></pre>"},{"location":"api/#pysquared.boot.filesystem.mkdir(mount_point)","title":"<code>mount_point</code>","text":"\u2013            <p>Path to mount point</p>"},{"location":"api/#pysquared.boot.filesystem.mkdir(storage_action_delay)","title":"<code>storage_action_delay</code>","text":"(<code>float</code>, default:                   <code>0.02</code> )           \u2013            <p>Delay after storage actions to ensure stability</p>"},{"location":"api/#pysquared.cdh","title":"cdh","text":"<p>This module provides the CommandDataHandler for managing and processing commands.</p> <p>This module is responsible for handling commands received by the satellite. It includes command parsing, validation, execution, and handling of radio communications. The CommandDataHandler class is the main entry point for this functionality.</p> <p>Usage: <pre><code>logger = Logger()\nconfig = Config(\"config.json\")\npacket_manager = PacketManager(logger, radio)\ncdh = CommandDataHandler(logger, config, packet_manager)\ncdh.listen_for_commands(timeout=60)\n</code></pre></p> <p>Classes:</p> <ul> <li> <code>CommandDataHandler</code>           \u2013            <p>Handles command parsing, validation, and execution for the satellite.</p> </li> </ul>"},{"location":"api/#pysquared.cdh.CommandDataHandler","title":"CommandDataHandler","text":"<pre><code>CommandDataHandler(logger: Logger, config: Config, packet_manager: PacketManager, send_delay: float = 0.2)\n</code></pre> <p>Handles command parsing, validation, and execution for the satellite.</p> <p>Parameters:</p> <p>Methods:</p> <ul> <li> <code>change_radio_modulation</code>             \u2013              <p>Changes the radio modulation.</p> </li> <li> <code>listen_for_commands</code>             \u2013              <p>Listens for commands from the radio and handles them.</p> </li> <li> <code>oscar_command</code>             \u2013              <p>Handles OSCAR commands.</p> </li> <li> <code>reset</code>             \u2013              <p>Resets the hardware.</p> </li> <li> <code>send_joke</code>             \u2013              <p>Sends a random joke from the config.</p> </li> </ul>"},{"location":"api/#pysquared.cdh.CommandDataHandler(logger)","title":"<code>logger</code>","text":"(<code>Logger</code>)           \u2013            <p>The logger to use.</p>"},{"location":"api/#pysquared.cdh.CommandDataHandler(config)","title":"<code>config</code>","text":"(<code>Config</code>)           \u2013            <p>The configuration to use.</p>"},{"location":"api/#pysquared.cdh.CommandDataHandler(packet_manager)","title":"<code>packet_manager</code>","text":"(<code>PacketManager</code>)           \u2013            <p>The packet manager to use for sending and receiving data.</p>"},{"location":"api/#pysquared.cdh.CommandDataHandler(send_delay)","title":"<code>send_delay</code>","text":"(<code>float</code>, default:                   <code>0.2</code> )           \u2013            <p>The delay between sending an acknowledgement and the response.</p>"},{"location":"api/#pysquared.cdh.CommandDataHandler.change_radio_modulation","title":"change_radio_modulation","text":"<pre><code>change_radio_modulation(args: list[str]) -&gt; None\n</code></pre> <p>Changes the radio modulation.</p> <p>Parameters:</p>"},{"location":"api/#pysquared.cdh.CommandDataHandler.change_radio_modulation(args)","title":"<code>args</code>","text":"(<code>list[str]</code>)           \u2013            <p>A list of arguments, the first item must be the new modulation. All other items in the args list are ignored.</p>"},{"location":"api/#pysquared.cdh.CommandDataHandler.listen_for_commands","title":"listen_for_commands","text":"<pre><code>listen_for_commands(timeout: int) -&gt; None\n</code></pre> <p>Listens for commands from the radio and handles them.</p> <p>Parameters:</p>"},{"location":"api/#pysquared.cdh.CommandDataHandler.listen_for_commands(timeout)","title":"<code>timeout</code>","text":"(<code>int</code>)           \u2013            <p>The time in seconds to listen for commands.</p>"},{"location":"api/#pysquared.cdh.CommandDataHandler.oscar_command","title":"oscar_command","text":"<pre><code>oscar_command(command: str, args: list[str]) -&gt; None\n</code></pre> <p>Handles OSCAR commands.</p> <p>Parameters:</p>"},{"location":"api/#pysquared.cdh.CommandDataHandler.oscar_command(command)","title":"<code>command</code>","text":"(<code>str</code>)           \u2013            <p>The OSCAR command to execute.</p>"},{"location":"api/#pysquared.cdh.CommandDataHandler.oscar_command(args)","title":"<code>args</code>","text":"(<code>list[str]</code>)           \u2013            <p>A list of arguments for the command.</p>"},{"location":"api/#pysquared.cdh.CommandDataHandler.reset","title":"reset","text":"<pre><code>reset() -&gt; None\n</code></pre> <p>Resets the hardware.</p>"},{"location":"api/#pysquared.cdh.CommandDataHandler.send_joke","title":"send_joke","text":"<pre><code>send_joke() -&gt; None\n</code></pre> <p>Sends a random joke from the config.</p>"},{"location":"api/#pysquared.config","title":"config","text":"<p>This module provides an interface for managing configuration settings in the PySquared project.</p> <p>Modules:</p> <ul> <li> <code>config</code>           \u2013            <p>This module provides the Config, which encapsulates the configuration</p> </li> <li> <code>radio</code>           \u2013            <p>This module provides classes for handling and validating radio configuration parameters, including support for both FSK and LoRa modulation schemes.</p> </li> </ul>"},{"location":"api/#pysquared.config.config","title":"config","text":"<p>This module provides the Config, which encapsulates the configuration logic for the PySquared project. It loads, validates, and updates configuration values from a JSON file, and distributes these values across the application.</p> <p>Classes:</p> <ul> <li> <code>Config</code>           \u2013            <p>Handles loading, validating, and updating configuration values, including radio settings.</p> </li> </ul> <p>Usage: <pre><code>config = Config(\"config.json\")\nconfig.update_config(\"cubesat_name\", \"Cube1\", temporary=False)\n</code></pre></p>"},{"location":"api/#pysquared.config.config.Config","title":"Config","text":"<pre><code>Config(config_path: str)\n</code></pre> <p>Configuration handler for PySquared.</p> <p>Loads configuration from a JSON file, validates values, and provides methods to update configuration settings. Supports both temporary (RAM-only) and permanent (file-persisted) updates. Delegates radio-related validation and updates to the RadioConfig class. Jokes are loaded from a separate jokes.json file in the same directory as the config file.</p> <p>Attributes:</p> <ul> <li> <code>config_file</code>               (<code>str</code>)           \u2013            <p>Path to the configuration JSON file.</p> </li> <li> <code>radio</code>               (<code>RadioConfig</code>)           \u2013            <p>Radio configuration handler.</p> </li> <li> <code>cubesat_name</code>               (<code>str</code>)           \u2013            <p>Name of the cubesat.</p> </li> <li> <code>sleep_duration</code>               (<code>int</code>)           \u2013            <p>Sleep duration in seconds.</p> </li> <li> <code>detumble_enable_z</code>               (<code>bool</code>)           \u2013            <p>Enable detumbling on Z axis.</p> </li> <li> <code>detumble_enable_x</code>               (<code>bool</code>)           \u2013            <p>Enable detumbling on X axis.</p> </li> <li> <code>detumble_enable_y</code>               (<code>bool</code>)           \u2013            <p>Enable detumbling on Y axis.</p> </li> <li> <code>jokes</code>               (<code>list[str]</code>)           \u2013            <p>List of jokes for the cubesat (loaded from jokes.json).</p> </li> <li> <code>debug</code>               (<code>bool</code>)           \u2013            <p>Debug mode flag.</p> </li> <li> <code>heating</code>               (<code>bool</code>)           \u2013            <p>Heating system enabled flag.</p> </li> <li> <code>normal_temp</code>               (<code>int</code>)           \u2013            <p>Normal operating temperature.</p> </li> <li> <code>normal_battery_temp</code>               (<code>int</code>)           \u2013            <p>Normal battery temperature.</p> </li> <li> <code>normal_micro_temp</code>               (<code>int</code>)           \u2013            <p>Normal microcontroller temperature.</p> </li> <li> <code>normal_charge_current</code>               (<code>float</code>)           \u2013            <p>Normal charge current.</p> </li> <li> <code>normal_battery_voltage</code>               (<code>float</code>)           \u2013            <p>Normal battery voltage.</p> </li> <li> <code>critical_battery_voltage</code>               (<code>float</code>)           \u2013            <p>Critical battery voltage.</p> </li> <li> <code>reboot_time</code>               (<code>int</code>)           \u2013            <p>Time before reboot in seconds.</p> </li> <li> <code>turbo_clock</code>               (<code>bool</code>)           \u2013            <p>Turbo clock enabled flag.</p> </li> <li> <code>super_secret_code</code>               (<code>str</code>)           \u2013            <p>Secret code for special operations.</p> </li> <li> <code>repeat_code</code>               (<code>str</code>)           \u2013            <p>Code for repeated operations.</p> </li> <li> <code>longest_allowable_sleep_time</code>               (<code>int</code>)           \u2013            <p>Maximum allowable sleep time.</p> </li> <li> <code>CONFIG_SCHEMA</code>               (<code>dict</code>)           \u2013            <p>Validation schema for configuration keys.</p> </li> </ul> <p>Methods:</p> <ul> <li> <code>validate</code>             \u2013              <p>Validates a configuration value against its schema.</p> </li> <li> <code>_save_config</code>             \u2013              <p>Saves a configuration value to the JSON file.</p> </li> <li> <code>update_config</code>             \u2013              <p>Updates a configuration value, either temporarily or permanently.</p> </li> </ul> <p>Parameters:</p> <ul> <li> </li> </ul> <p>Raises:</p> <ul> <li> <code>FileNotFoundError</code>             \u2013            <p>If the configuration file or jokes.json does not exist.</p> </li> <li> <code>JSONDecodeError</code>             \u2013            <p>If the configuration file or jokes.json is not valid JSON.</p> </li> </ul>"},{"location":"api/#pysquared.config.config.Config(config_path)","title":"<code>config_path</code>","text":"(<code>str</code>)           \u2013            <p>Path to the configuration JSON file.</p>"},{"location":"api/#pysquared.config.config.Config.update_config","title":"update_config","text":"<pre><code>update_config(key: str, value, temporary: bool) -&gt; None\n</code></pre> <p>Updates a configuration value, either temporarily (RAM only) or permanently (persisted to file).</p> <p>Parameters:</p> <p>Raises:</p> <ul> <li> <code>TypeError</code>             \u2013            <p>If the value is not of the expected type.</p> </li> <li> <code>ValueError</code>             \u2013            <p>If the value is out of the allowed range or length.</p> </li> </ul>"},{"location":"api/#pysquared.config.config.Config.update_config(key)","title":"<code>key</code>","text":"(<code>str</code>)           \u2013            <p>The configuration key to update.</p>"},{"location":"api/#pysquared.config.config.Config.update_config(value)","title":"<code>value</code>","text":"\u2013            <p>The new value to set.</p>"},{"location":"api/#pysquared.config.config.Config.update_config(temporary)","title":"<code>temporary</code>","text":"(<code>bool</code>)           \u2013            <p>If True, update only in RAM; if False, persist to file.</p>"},{"location":"api/#pysquared.config.config.Config.validate","title":"validate","text":"<pre><code>validate(key: str, value) -&gt; None\n</code></pre> <p>Validates a configuration value against its schema.</p> <p>Parameters:</p> <p>Raises:</p> <ul> <li> <code>TypeError</code>             \u2013            <p>If the value is not of the expected type.</p> </li> <li> <code>ValueError</code>             \u2013            <p>If the value is out of the allowed range or length.</p> </li> </ul>"},{"location":"api/#pysquared.config.config.Config.validate(key)","title":"<code>key</code>","text":"(<code>str</code>)           \u2013            <p>The configuration key to validate.</p>"},{"location":"api/#pysquared.config.config.Config.validate(value)","title":"<code>value</code>","text":"\u2013            <p>The value to validate.</p>"},{"location":"api/#pysquared.config.radio","title":"radio","text":"<p>This module provides classes for handling and validating radio configuration parameters, including support for both FSK and LoRa modulation schemes.</p> <p>Classes:</p> <ul> <li> <code>RadioConfig</code>           \u2013            <p>Handles top-level radio configuration and validation.</p> </li> <li> <code>FSKConfig</code>           \u2013            <p>Handles FSK-specific configuration and validation.</p> </li> <li> <code>LORAConfig</code>           \u2013            <p>Handles LoRa-specific configuration and validation.</p> </li> </ul>"},{"location":"api/#pysquared.config.radio.FSKConfig","title":"FSKConfig","text":"<pre><code>FSKConfig(fsk_dict: dict)\n</code></pre> <p>Handles FSK-specific radio configuration and validation.</p> <p>Attributes:</p> <ul> <li> <code>broadcast_address</code>               (<code>int</code>)           \u2013            <p>Broadcast address for FSK.</p> </li> <li> <code>node_address</code>               (<code>int</code>)           \u2013            <p>Node address for FSK.</p> </li> <li> <code>modulation_type</code>               (<code>int</code>)           \u2013            <p>Modulation type for FSK.</p> </li> <li> <code>FSK_SCHEMA</code>               (<code>dict</code>)           \u2013            <p>Validation schema for FSK configuration keys.</p> </li> </ul> <p>Parameters:</p> <ul> <li> </li> </ul>"},{"location":"api/#pysquared.config.radio.FSKConfig(fsk_dict)","title":"<code>fsk_dict</code>","text":"(<code>dict</code>)           \u2013            <p>Dictionary containing FSK configuration values.</p>"},{"location":"api/#pysquared.config.radio.LORAConfig","title":"LORAConfig","text":"<pre><code>LORAConfig(lora_dict: dict)\n</code></pre> <p>Handles LoRa-specific radio configuration and validation.</p> <p>Attributes:</p> <ul> <li> <code>ack_delay</code>               (<code>float</code>)           \u2013            <p>Acknowledgement delay in seconds.</p> </li> <li> <code>coding_rate</code>               (<code>int</code>)           \u2013            <p>Coding rate for LoRa.</p> </li> <li> <code>cyclic_redundancy_check</code>               (<code>bool</code>)           \u2013            <p>CRC enabled flag.</p> </li> <li> <code>spreading_factor</code>               (<code>Literal[6, 7, 8, 9, 10, 11, 12]</code>)           \u2013            <p>LoRa spreading factor.</p> </li> <li> <code>transmit_power</code>               (<code>int</code>)           \u2013            <p>Transmit power in dBm.</p> </li> <li> <code>LORA_SCHEMA</code>               (<code>dict</code>)           \u2013            <p>Validation schema for LoRa configuration keys.</p> </li> </ul> <p>Parameters:</p> <ul> <li> </li> </ul>"},{"location":"api/#pysquared.config.radio.LORAConfig(lora_dict)","title":"<code>lora_dict</code>","text":"(<code>dict</code>)           \u2013            <p>Dictionary containing LoRa configuration values.</p>"},{"location":"api/#pysquared.config.radio.RadioConfig","title":"RadioConfig","text":"<pre><code>RadioConfig(radio_dict: dict)\n</code></pre> <p>Handles radio configuration and validation for PySquared.</p> <p>Attributes:</p> <ul> <li> <code>license</code>               (<code>str</code>)           \u2013            <p>The radio license identifier.</p> </li> <li> <code>modulation</code>               (<code>Literal['LoRa', 'FSK']</code>)           \u2013            <p>The modulation type.</p> </li> <li> <code>transmit_frequency</code>               (<code>int</code>)           \u2013            <p>The transmission frequency in MHz.</p> </li> <li> <code>start_time</code>               (<code>int</code>)           \u2013            <p>The radio start time in seconds.</p> </li> <li> <code>fsk</code>               (<code>FSKConfig</code>)           \u2013            <p>FSK-specific configuration handler.</p> </li> <li> <code>lora</code>               (<code>LORAConfig</code>)           \u2013            <p>LoRa-specific configuration handler.</p> </li> <li> <code>RADIO_SCHEMA</code>               (<code>dict</code>)           \u2013            <p>Validation schema for radio configuration keys.</p> </li> </ul> <p>Methods:</p> <ul> <li> <code>validate</code>             \u2013              <p>Validates a radio configuration value against its schema.</p> </li> </ul> <p>Parameters:</p> <ul> <li> </li> </ul>"},{"location":"api/#pysquared.config.radio.RadioConfig(radio_dict)","title":"<code>radio_dict</code>","text":"(<code>dict</code>)           \u2013            <p>Dictionary containing radio configuration values.</p>"},{"location":"api/#pysquared.config.radio.RadioConfig.validate","title":"validate","text":"<pre><code>validate(key: str, value) -&gt; None\n</code></pre> <p>Validates a radio configuration value against its schema.</p> <p>Parameters:</p> <p>Raises:</p> <ul> <li> <code>KeyError</code>             \u2013            <p>If the key is not found in any schema.</p> </li> <li> <code>TypeError</code>             \u2013            <p>If the value is not of the expected type or not allowed.</p> </li> <li> <code>ValueError</code>             \u2013            <p>If the value is out of the allowed range.</p> </li> </ul>"},{"location":"api/#pysquared.config.radio.RadioConfig.validate(key)","title":"<code>key</code>","text":"(<code>str</code>)           \u2013            <p>The configuration key to validate.</p>"},{"location":"api/#pysquared.config.radio.RadioConfig.validate(value)","title":"<code>value</code>","text":"\u2013            <p>The value to validate.</p>"},{"location":"api/#pysquared.detumble","title":"detumble","text":"<p>This module provides functions for satellite detumbling using magnetorquers. Includes vector math utilities and the main dipole calculation for attitude control.</p> <p>Functions:</p> <ul> <li> <code>dot_product</code>             \u2013              <p>Computes the dot product of two 3-element vectors.</p> </li> <li> <code>gain_func</code>             \u2013              <p>Returns the gain value for the detumble control law.</p> </li> <li> <code>magnetorquer_dipole</code>             \u2013              <p>Calculates the required dipole moment for the magnetorquers to detumble the satellite.</p> </li> <li> <code>x_product</code>             \u2013              <p>Computes the cross product of two 3-element vectors.</p> </li> </ul>"},{"location":"api/#pysquared.detumble.dot_product","title":"dot_product","text":"<pre><code>dot_product(vector1: tuple, vector2: tuple) -&gt; float\n</code></pre> <p>Computes the dot product of two 3-element vectors.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>float</code> (              <code>float</code> )          \u2013            <p>The dot product of the two vectors.</p> </li> </ul>"},{"location":"api/#pysquared.detumble.dot_product(vector1)","title":"<code>vector1</code>","text":"(<code>tuple</code>)           \u2013            <p>First vector (length 3).</p>"},{"location":"api/#pysquared.detumble.dot_product(vector2)","title":"<code>vector2</code>","text":"(<code>tuple</code>)           \u2013            <p>Second vector (length 3).</p>"},{"location":"api/#pysquared.detumble.gain_func","title":"gain_func","text":"<pre><code>gain_func() -&gt; float\n</code></pre> <p>Returns the gain value for the detumble control law.</p> <p>Returns:</p> <ul> <li> <code>float</code> (              <code>float</code> )          \u2013            <p>Gain value (default 1.0).</p> </li> </ul>"},{"location":"api/#pysquared.detumble.magnetorquer_dipole","title":"magnetorquer_dipole","text":"<pre><code>magnetorquer_dipole(mag_field: tuple, ang_vel: tuple) -&gt; list\n</code></pre> <p>Calculates the required dipole moment for the magnetorquers to detumble the satellite.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>list</code> (              <code>list</code> )          \u2013            <p>The dipole moment vector to be applied (length 3).</p> </li> </ul>"},{"location":"api/#pysquared.detumble.magnetorquer_dipole(mag_field)","title":"<code>mag_field</code>","text":"(<code>tuple</code>)           \u2013            <p>The measured magnetic field vector (length 3).</p>"},{"location":"api/#pysquared.detumble.magnetorquer_dipole(ang_vel)","title":"<code>ang_vel</code>","text":"(<code>tuple</code>)           \u2013            <p>The measured angular velocity vector (length 3).</p>"},{"location":"api/#pysquared.detumble.x_product","title":"x_product","text":"<pre><code>x_product(vector1: tuple, vector2: tuple) -&gt; list\n</code></pre> <p>Computes the cross product of two 3-element vectors.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>list</code> (              <code>list</code> )          \u2013            <p>The cross product vector (length 3).</p> </li> </ul>"},{"location":"api/#pysquared.detumble.x_product(vector1)","title":"<code>vector1</code>","text":"(<code>tuple</code>)           \u2013            <p>First vector (length 3).</p>"},{"location":"api/#pysquared.detumble.x_product(vector2)","title":"<code>vector2</code>","text":"(<code>tuple</code>)           \u2013            <p>Second vector (length 3).</p>"},{"location":"api/#pysquared.file_validation","title":"file_validation","text":"<p>File validation package for PySquared.</p> <p>Modules:</p> <ul> <li> <code>manager</code>           \u2013            <p>File validation manager package.</p> </li> </ul>"},{"location":"api/#pysquared.file_validation.manager","title":"manager","text":"<p>File validation manager package.</p> <p>Modules:</p> <ul> <li> <code>file_validation</code>           \u2013            <p>File Validation Manager implementation.</p> </li> </ul>"},{"location":"api/#pysquared.file_validation.manager.file_validation","title":"file_validation","text":"<p>File Validation Manager implementation.</p> <p>This module provides file validation functionality for creating checksums, validating file integrity, and assessing codebase completeness in CircuitPython.</p> Usage Example <pre><code>import board\nfrom pysquared.logger import Logger\nfrom pysquared.file_validation.manager.file_validation import FileValidationManager\n\n# Initialize logger\nlogger = Logger(\"file_validation\")\n\n# Create file validation manager\nfile_validator = FileValidationManager(logger)\n\n# Create checksum for a single file (MD5 by default for speed)\n# Memory usage is automatically optimized for constrained devices like RP2040\nchecksum = file_validator.create_file_checksum(\"main.py\")\nprint(f\"main.py checksum: {checksum}\")\n\n# Create checksum with specific algorithm\nsha256_checksum = file_validator.create_file_checksum(\"config.py\", algorithm=\"sha256\")\nprint(f\"config.py SHA256: {sha256_checksum}\")\n\n# Validate file integrity\nexpected_checksum = \"d41d8cd98f00b204e9800998ecf8427e\"\nis_valid = file_validator.validate_file_integrity(\"main.py\", expected_checksum)\nprint(f\"File integrity: {'PASS' if is_valid else 'FAIL'}\")\n\n# Create checksums for entire codebase\n# Hidden files (starting with .) are automatically ignored\nchecksums = file_validator.create_codebase_checksum(\"/\", exclude_patterns=[\"__pycache__\", \".pyc\"])\nprint(f\"Codebase has {len(checksums)} files\")\n\n# Assess codebase completeness\nassessment = file_validator.assess_codebase_completeness(\"/\", checksums)\nprint(f\"Codebase complete: {assessment['is_complete']}\")\nprint(f\"Codebase valid: {assessment['is_valid']}\")\nprint(f\"Missing files: {assessment['missing_files']}\")\nprint(f\"Extra files: {assessment['extra_files']}\")\n\n# Get file and codebase sizes\nfile_size = file_validator.get_file_size(\"main.py\")\ncodebase_size = file_validator.get_codebase_size(\"/\")\nprint(f\"main.py size: {file_size} bytes\")\nprint(f\"Codebase size: {codebase_size} bytes\")\n</code></pre> <p>Classes:</p> <ul> <li> <code>FileValidationManager</code>           \u2013            <p>File validation functionality for CircuitPython applications.</p> </li> </ul>"},{"location":"api/#pysquared.file_validation.manager.file_validation.FileValidationManager","title":"FileValidationManager","text":"<pre><code>FileValidationManager(logger: Logger)\n</code></pre> <p>File validation functionality for CircuitPython applications.</p> <p>:param Logger logger: Logger instance for logging messages.</p> <p>Methods:</p> <ul> <li> <code>assess_codebase_completeness</code>             \u2013              <p>Assess the completeness and integrity of the codebase.</p> </li> <li> <code>create_codebase_checksum</code>             \u2013              <p>Create checksums for all files in the codebase.</p> </li> <li> <code>create_file_checksum</code>             \u2013              <p>Create a checksum for a single file.</p> </li> <li> <code>get_codebase_size</code>             \u2013              <p>Get the total size of all files in the codebase.</p> </li> <li> <code>get_extra_files</code>             \u2013              <p>Get a list of files that exist but are not in the expected file list.</p> </li> <li> <code>get_file_size</code>             \u2013              <p>Get the size of a file in bytes.</p> </li> <li> <code>get_missing_files</code>             \u2013              <p>Get a list of files that are expected but missing from the codebase.</p> </li> <li> <code>validate_codebase_integrity</code>             \u2013              <p>Validate the integrity of all files in the codebase against expected checksums.</p> </li> <li> <code>validate_file_integrity</code>             \u2013              <p>Validate the integrity of a single file against an expected checksum.</p> </li> </ul>"},{"location":"api/#pysquared.file_validation.manager.file_validation.FileValidationManager.assess_codebase_completeness","title":"assess_codebase_completeness","text":"<pre><code>assess_codebase_completeness(base_path: str, expected_checksums: dict) -&gt; dict\n</code></pre> <p>Assess the completeness and integrity of the codebase.</p> <p>:param str base_path: The base directory path to scan for files. :param Dict[str, str] expected_checksums: Dictionary mapping file paths to their expected checksums. :return: A dictionary containing assessment results including:          - is_complete: bool - Whether all expected files are present          - is_valid: bool - Whether all present files have correct checksums          - missing_files: List[str] - List of missing files          - extra_files: List[str] - List of unexpected files          - corrupted_files: List[str] - List of files with incorrect checksums          - total_files: int - Total number of files checked          - valid_files: int - Number of files with correct checksums :rtype: Dict[str, Any] :raises RuntimeError: If there is an error during assessment.</p>"},{"location":"api/#pysquared.file_validation.manager.file_validation.FileValidationManager.create_codebase_checksum","title":"create_codebase_checksum","text":"<pre><code>create_codebase_checksum(base_path: str, exclude_patterns: list | None = None) -&gt; dict\n</code></pre> <p>Create checksums for all files in the codebase.</p> <p>:param str base_path: The base directory path to scan for files. :param List[str] | None exclude_patterns: Optional list of file patterns to exclude from checksumming. :return: A dictionary mapping file paths to their checksums. :rtype: Dict[str, str] :raises ValueError: If the base path is not found. :raises RuntimeError: If there is an error scanning the directory or creating checksums.</p>"},{"location":"api/#pysquared.file_validation.manager.file_validation.FileValidationManager.create_file_checksum","title":"create_file_checksum","text":"<pre><code>create_file_checksum(file_path: str, timeout: float = 10.0, algorithm: str = 'md5') -&gt; str\n</code></pre> <p>Create a checksum for a single file.</p> <p>:param str file_path: The path to the file to checksum. :param float timeout: Maximum time (in seconds) to allow for reading the file. Default is 5 seconds. :param str algorithm: Hash algorithm to use ('md5', 'sha1', 'sha224', 'sha256', 'sha512'). Default is 'md5' for speed. :return: The checksum of the file as a hexadecimal string. :rtype: str :raises FileNotFoundError: If the file is not found. :raises TimeoutError: If reading the file takes longer than the timeout. :raises MemoryError: If there is insufficient memory to process the file. :raises RuntimeError: If there is an error reading the file or creating the checksum.</p>"},{"location":"api/#pysquared.file_validation.manager.file_validation.FileValidationManager.get_codebase_size","title":"get_codebase_size","text":"<pre><code>get_codebase_size(base_path: str, exclude_patterns: list | None = None) -&gt; int\n</code></pre> <p>Get the total size of all files in the codebase.</p> <p>:param str base_path: The base directory path to scan for files. :param List[str] | None exclude_patterns: Optional list of file patterns to exclude. :return: The total size of all files in bytes. :rtype: int :raises ValueError: If the base path is not found. :raises RuntimeError: If there is an error scanning the directory.</p>"},{"location":"api/#pysquared.file_validation.manager.file_validation.FileValidationManager.get_extra_files","title":"get_extra_files","text":"<pre><code>get_extra_files(base_path: str, expected_files: list) -&gt; list\n</code></pre> <p>Get a list of files that exist but are not in the expected file list.</p> <p>:param str base_path: The base directory path to scan for files. :param List[str] expected_files: List of file paths that should exist. :return: List of file paths that are extra/unexpected. :rtype: List[str] :raises RuntimeError: If there is an error scanning the directory.</p>"},{"location":"api/#pysquared.file_validation.manager.file_validation.FileValidationManager.get_file_size","title":"get_file_size","text":"<pre><code>get_file_size(file_path: str) -&gt; int\n</code></pre> <p>Get the size of a file in bytes.</p> <p>:param str file_path: The path to the file. :return: The size of the file in bytes. :rtype: int :raises FileNotFoundError: If the file is not found. :raises RuntimeError: If there is an error accessing the file.</p>"},{"location":"api/#pysquared.file_validation.manager.file_validation.FileValidationManager.get_missing_files","title":"get_missing_files","text":"<pre><code>get_missing_files(base_path: str, expected_files: list) -&gt; list\n</code></pre> <p>Get a list of files that are expected but missing from the codebase.</p> <p>:param str base_path: The base directory path to scan for files. :param List[str] expected_files: List of file paths that should exist. :return: List of file paths that are missing. :rtype: List[str] :raises RuntimeError: If there is an error scanning the directory.</p>"},{"location":"api/#pysquared.file_validation.manager.file_validation.FileValidationManager.validate_codebase_integrity","title":"validate_codebase_integrity","text":"<pre><code>validate_codebase_integrity(base_path: str, expected_checksums: dict) -&gt; tuple\n</code></pre> <p>Validate the integrity of all files in the codebase against expected checksums.</p> <p>:param str base_path: The base directory path to scan for files. :param Dict[str, str] expected_checksums: Dictionary mapping file paths to their expected checksums. :return: A tuple containing (is_valid, list_of_failed_files). :rtype: Tuple[bool, List[str]] :raises RuntimeError: If there is an error scanning the directory or validating files.</p>"},{"location":"api/#pysquared.file_validation.manager.file_validation.FileValidationManager.validate_file_integrity","title":"validate_file_integrity","text":"<pre><code>validate_file_integrity(file_path: str, expected_checksum: str) -&gt; bool\n</code></pre> <p>Validate the integrity of a single file against an expected checksum.</p> <p>:param str file_path: The path to the file to validate. :param str expected_checksum: The expected checksum to compare against. :return: True if the file checksum matches the expected checksum, False otherwise. :rtype: bool :raises FileNotFoundError: If the file is not found. :raises RuntimeError: If there is an error reading the file or creating the checksum.</p>"},{"location":"api/#pysquared.hardware","title":"hardware","text":"<p>This module provides managers for various hardware components including sensors, actuators, communication interfaces, etc.</p> <p>Modules:</p> <ul> <li> <code>burnwire</code>           \u2013            <p>This module provides an interface for controlling burnwire systems.</p> </li> <li> <code>busio</code>           \u2013            <p>This module provides functions for initializing and configuring SPI and I2C buses</p> </li> <li> <code>digitalio</code>           \u2013            <p>This module provides functions for initializing DigitalInOut pins on the PySquared</p> </li> <li> <code>exception</code>           \u2013            <p>This module provides a custom exception for hardware initialization errors.</p> </li> <li> <code>imu</code>           \u2013            <p>This module provides an interface for controlling inertial measurement units (IMUs).</p> </li> <li> <code>light_sensor</code>           \u2013            <p>This module provides an interface to the light sensors.</p> </li> <li> <code>load_switch</code>           \u2013            <p>Load switch hardware interface.</p> </li> <li> <code>magnetometer</code>           \u2013            <p>This module provides an interface for controlling magnetormeters.</p> </li> <li> <code>power_monitor</code>           \u2013            <p>This module provides an interface for controlling power monitors.</p> </li> <li> <code>radio</code>           \u2013            <p>This module provides an interface for controlling radios.</p> </li> <li> <code>temperature_sensor</code>           \u2013            <p>This module provides temperature sensor hardware managers.</p> </li> </ul>"},{"location":"api/#pysquared.hardware.burnwire","title":"burnwire","text":"<p>This module provides an interface for controlling burnwire systems.</p> <p>Modules:</p> <ul> <li> <code>manager</code>           \u2013            <p>This module provides the managers for various burnwire implementations</p> </li> </ul>"},{"location":"api/#pysquared.hardware.burnwire.manager","title":"manager","text":"<p>This module provides the managers for various burnwire implementations</p> <p>Modules:</p> <ul> <li> <code>burnwire</code>           \u2013            <p>This module defines the <code>BurnwireManager</code> class, which provides a high-level interface</p> </li> </ul>"},{"location":"api/#pysquared.hardware.burnwire.manager.burnwire","title":"burnwire","text":"<p>This module defines the <code>BurnwireManager</code> class, which provides a high-level interface for controlling burnwire circuits, which are commonly used for deployment mechanisms in satellites. It handles the timing and sequencing of the burnwire activation and provides error handling and logging.</p> <p>Usage: <pre><code>logger = Logger()\nenable_pin = DigitalInOut(board.D1)\nfire_pin = DigitalInOut(board.D2)\nburnwire = BurnwireManager(logger, enable_pin, fire_pin)\nburnwire.burn()\n</code></pre></p> <p>Classes:</p> <ul> <li> <code>BurnwireManager</code>           \u2013            <p>Manages the activation of a burnwire.</p> </li> </ul>"},{"location":"api/#pysquared.hardware.burnwire.manager.burnwire.BurnwireManager","title":"BurnwireManager","text":"<pre><code>BurnwireManager(logger: Logger, enable_burn: DigitalInOut, fire_burn: DigitalInOut, enable_logic: bool = True)\n</code></pre> <p>               Bases: <code>BurnwireProto</code></p> <p>Manages the activation of a burnwire.</p> <p>Parameters:</p> <ul> <li> <code>logger</code>               (<code>Logger</code>)           \u2013            <p>The logger to use.</p> </li> <li> <code>enable_burn</code>               (<code>DigitalInOut</code>)           \u2013            <p>The pin used to enable the burnwire circuit.</p> </li> <li> <code>fire_burn</code>               (<code>DigitalInOut</code>)           \u2013            <p>The pin used to fire the burnwire.</p> </li> <li> <code>enable_logic</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>The logic level to enable the burnwire.</p> </li> </ul> <p>Methods:</p> <ul> <li> <code>burn</code>             \u2013              <p>Fires the burnwire for a specified amount of time.</p> </li> </ul> <code></code> burn <pre><code>burn(timeout_duration: float = 5.0) -&gt; bool\n</code></pre> <p>Fires the burnwire for a specified amount of time.</p> <p>Parameters:</p> <ul> <li> <code>timeout_duration</code>               (<code>float</code>, default:                   <code>5.0</code> )           \u2013            <p>The maximum amount of time to keep the burnwire on.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>True if the burn was successful, False otherwise.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>Exception</code>             \u2013            <p>If there is an error toggling the burnwire pins.</p> </li> </ul>"},{"location":"api/#pysquared.hardware.busio","title":"busio","text":"<p>This module provides functions for initializing and configuring SPI and I2C buses on the PySquared satellite hardware. Includes retry logic for robust hardware initialization and error handling.</p> <p>Functions:</p> <ul> <li> <code>initialize_i2c_bus</code>             \u2013              <p>Initializes an I2C bus with the specified parameters. Includes retry logic.</p> </li> <li> <code>initialize_spi_bus</code>             \u2013              <p>Initializes and configures an SPI bus with the specified parameters.</p> </li> </ul>"},{"location":"api/#pysquared.hardware.busio.initialize_i2c_bus","title":"initialize_i2c_bus","text":"<pre><code>initialize_i2c_bus(logger: Logger, scl: Pin, sda: Pin, frequency: Optional[int]) -&gt; I2C\n</code></pre> <p>Initializes an I2C bus with the specified parameters. Includes retry logic.</p> <p>Parameters:</p> <p>Raises:</p> <ul> <li> <code>HardwareInitializationError</code>             \u2013            <p>If the I2C bus fails to initialize.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>I2C</code> (              <code>I2C</code> )          \u2013            <p>The initialized I2C object.</p> </li> </ul>"},{"location":"api/#pysquared.hardware.busio.initialize_i2c_bus(logger)","title":"<code>logger</code>","text":"(<code>Logger</code>)           \u2013            <p>Logger instance to log messages.</p>"},{"location":"api/#pysquared.hardware.busio.initialize_i2c_bus(scl)","title":"<code>scl</code>","text":"(<code>Pin</code>)           \u2013            <p>The pin to use for the SCL signal.</p>"},{"location":"api/#pysquared.hardware.busio.initialize_i2c_bus(sda)","title":"<code>sda</code>","text":"(<code>Pin</code>)           \u2013            <p>The pin to use for the SDA signal.</p>"},{"location":"api/#pysquared.hardware.busio.initialize_i2c_bus(frequency)","title":"<code>frequency</code>","text":"(<code>Optional[int]</code>)           \u2013            <p>The baudrate of the I2C bus (default 100000).</p>"},{"location":"api/#pysquared.hardware.busio.initialize_spi_bus","title":"initialize_spi_bus","text":"<pre><code>initialize_spi_bus(logger: Logger, clock: Pin, mosi: Optional[Pin] = None, miso: Optional[Pin] = None, baudrate: Optional[int] = 100000, phase: Optional[int] = 0, polarity: Optional[int] = 0, bits: Optional[int] = 8) -&gt; SPI\n</code></pre> <p>Initializes and configures an SPI bus with the specified parameters.</p> <p>Parameters:</p> <p>Raises:</p> <ul> <li> <code>HardwareInitializationError</code>             \u2013            <p>If the SPI bus fails to initialize.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>SPI</code> (              <code>SPI</code> )          \u2013            <p>The initialized SPI object.</p> </li> </ul>"},{"location":"api/#pysquared.hardware.busio.initialize_spi_bus(logger)","title":"<code>logger</code>","text":"(<code>Logger</code>)           \u2013            <p>Logger instance to log messages.</p>"},{"location":"api/#pysquared.hardware.busio.initialize_spi_bus(clock)","title":"<code>clock</code>","text":"(<code>Pin</code>)           \u2013            <p>The pin to use for the clock signal.</p>"},{"location":"api/#pysquared.hardware.busio.initialize_spi_bus(mosi)","title":"<code>mosi</code>","text":"(<code>Optional[Pin]</code>, default:                   <code>None</code> )           \u2013            <p>The pin to use for the MOSI signal.</p>"},{"location":"api/#pysquared.hardware.busio.initialize_spi_bus(miso)","title":"<code>miso</code>","text":"(<code>Optional[Pin]</code>, default:                   <code>None</code> )           \u2013            <p>The pin to use for the MISO signal.</p>"},{"location":"api/#pysquared.hardware.busio.initialize_spi_bus(baudrate)","title":"<code>baudrate</code>","text":"(<code>Optional[int]</code>, default:                   <code>100000</code> )           \u2013            <p>The baudrate of the SPI bus (default 100000).</p>"},{"location":"api/#pysquared.hardware.busio.initialize_spi_bus(phase)","title":"<code>phase</code>","text":"(<code>Optional[int]</code>, default:                   <code>0</code> )           \u2013            <p>The phase of the SPI bus (default 0).</p>"},{"location":"api/#pysquared.hardware.busio.initialize_spi_bus(polarity)","title":"<code>polarity</code>","text":"(<code>Optional[int]</code>, default:                   <code>0</code> )           \u2013            <p>The polarity of the SPI bus (default 0).</p>"},{"location":"api/#pysquared.hardware.busio.initialize_spi_bus(bits)","title":"<code>bits</code>","text":"(<code>Optional[int]</code>, default:                   <code>8</code> )           \u2013            <p>The number of bits per transfer (default 8).</p>"},{"location":"api/#pysquared.hardware.digitalio","title":"digitalio","text":"<p>This module provides functions for initializing DigitalInOut pins on the PySquared satellite hardware. Includes retry logic for robust hardware initialization and error handling.</p> <p>Functions:</p> <ul> <li> <code>initialize_pin</code>             \u2013              <p>Initializes a DigitalInOut pin with the specified direction and initial value.</p> </li> </ul>"},{"location":"api/#pysquared.hardware.digitalio.initialize_pin","title":"initialize_pin","text":"<pre><code>initialize_pin(logger: Logger, pin: Pin, direction: Direction, initial_value: bool) -&gt; DigitalInOut\n</code></pre> <p>Initializes a DigitalInOut pin with the specified direction and initial value.</p> <p>Parameters:</p> <p>Raises:</p> <ul> <li> <code>HardwareInitializationError</code>             \u2013            <p>If the pin fails to initialize.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>DigitalInOut</code> (              <code>DigitalInOut</code> )          \u2013            <p>The initialized DigitalInOut object.</p> </li> </ul>"},{"location":"api/#pysquared.hardware.digitalio.initialize_pin(logger)","title":"<code>logger</code>","text":"(<code>Logger</code>)           \u2013            <p>The logger instance to log messages.</p>"},{"location":"api/#pysquared.hardware.digitalio.initialize_pin(pin)","title":"<code>pin</code>","text":"(<code>Pin</code>)           \u2013            <p>The pin to initialize.</p>"},{"location":"api/#pysquared.hardware.digitalio.initialize_pin(direction)","title":"<code>direction</code>","text":"(<code>Direction</code>)           \u2013            <p>The direction of the pin.</p>"},{"location":"api/#pysquared.hardware.digitalio.initialize_pin(initial_value)","title":"<code>initial_value</code>","text":"(<code>bool</code>)           \u2013            <p>The initial value of the pin (default is True).</p>"},{"location":"api/#pysquared.hardware.exception","title":"exception","text":"<p>This module provides a custom exception for hardware initialization errors.</p> <p>This exception is raised when a hardware component fails to initialize after a certain number of retries.</p> <p>Usage: <pre><code>raise HardwareInitializationError(\"Failed to initialize the IMU.\")\n</code></pre></p> <p>Classes:</p> <ul> <li> <code>HardwareInitializationError</code>           \u2013            <p>Exception raised for errors in hardware initialization.</p> </li> </ul>"},{"location":"api/#pysquared.hardware.exception.HardwareInitializationError","title":"HardwareInitializationError","text":"<p>               Bases: <code>Exception</code></p> <p>Exception raised for errors in hardware initialization.</p>"},{"location":"api/#pysquared.hardware.imu","title":"imu","text":"<p>This module provides an interface for controlling inertial measurement units (IMUs).</p> <p>Modules:</p> <ul> <li> <code>manager</code>           \u2013            <p>This module provides the managers for various inertial measurement unit (IMU) implementations</p> </li> </ul>"},{"location":"api/#pysquared.hardware.imu.manager","title":"manager","text":"<p>This module provides the managers for various inertial measurement unit (IMU) implementations</p> <p>Modules:</p> <ul> <li> <code>lsm6dsox</code>           \u2013            <p>This module defines the <code>LSM6DSOXManager</code> class, which provides a high-level interface</p> </li> </ul>"},{"location":"api/#pysquared.hardware.imu.manager.lsm6dsox","title":"lsm6dsox","text":"<p>This module defines the <code>LSM6DSOXManager</code> class, which provides a high-level interface for interacting with the LSM6DSOX inertial measurement unit. It handles the initialization of the sensor and provides methods for reading angular_velocity, acceleration, and temperature data.</p> <p>Usage: <pre><code>logger = Logger()\ni2c = busio.I2C(board.SCL, board.SDA)\nimu = LSM6DSOXManager(logger, i2c, 0x6A)\nangular_velocity = imu.get_angular_velocity()\naccel_data = imu.get_acceleration()\ntemp_data = imu.get_temperature()\n</code></pre></p> <p>Classes:</p> <ul> <li> <code>LSM6DSOXManager</code>           \u2013            <p>Manages the LSM6DSOX IMU.</p> </li> </ul>"},{"location":"api/#pysquared.hardware.imu.manager.lsm6dsox.LSM6DSOXManager","title":"LSM6DSOXManager","text":"<pre><code>LSM6DSOXManager(logger: Logger, i2c: I2C, address: int)\n</code></pre> <p>               Bases: <code>IMUProto</code>, <code>TemperatureSensorProto</code></p> <p>Manages the LSM6DSOX IMU.</p> <p>Parameters:</p> <ul> <li> <code>logger</code>               (<code>Logger</code>)           \u2013            <p>The logger to use.</p> </li> <li> <code>i2c</code>               (<code>I2C</code>)           \u2013            <p>The I2C bus connected to the chip.</p> </li> <li> <code>address</code>               (<code>int</code>)           \u2013            <p>The I2C address of the IMU.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>HardwareInitializationError</code>             \u2013            <p>If the IMU fails to initialize.</p> </li> </ul> <p>Methods:</p> <ul> <li> <code>get_acceleration</code>             \u2013              <p>Gets the acceleration data from the IMU.</p> </li> <li> <code>get_angular_velocity</code>             \u2013              <p>Gets the angular velocity from the IMU.</p> </li> <li> <code>get_temperature</code>             \u2013              <p>Gets the temperature reading from the IMU.</p> </li> </ul> <code></code> get_acceleration <pre><code>get_acceleration() -&gt; Acceleration\n</code></pre> <p>Gets the acceleration data from the IMU.</p> <p>Returns:</p> <ul> <li> <code>Acceleration</code>           \u2013            <p>An Acceleration object containing the x, y, and z acceleration values in m/s\u00b2.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>SensorReadingUnknownError</code>             \u2013            <p>If an unknown error occurs while reading the acceleration data.</p> </li> </ul> <code></code> get_angular_velocity <pre><code>get_angular_velocity() -&gt; AngularVelocity\n</code></pre> <p>Gets the angular velocity from the IMU.</p> <p>Returns:</p> <ul> <li> <code>AngularVelocity</code>           \u2013            <p>An AngularVelocity object containing the x, y, and z angular velocity in radians per second.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>SensorReadingUnknownError</code>             \u2013            <p>If an unknown error occurs while reading the angular velocity.</p> </li> </ul> <code></code> get_temperature <pre><code>get_temperature() -&gt; Temperature\n</code></pre> <p>Gets the temperature reading from the IMU.</p> <p>Returns:</p> <ul> <li> <code>Temperature</code>           \u2013            <p>A Temperature object containing the temperature in degrees Celsius.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>SensorReadingUnknownError</code>             \u2013            <p>If an unknown error occurs while reading the temperature.</p> </li> </ul>"},{"location":"api/#pysquared.hardware.light_sensor","title":"light_sensor","text":"<p>This module provides an interface to the light sensors.</p> <p>Modules:</p> <ul> <li> <code>manager</code>           \u2013            <p>These managers interface with specific light sensor implementations.</p> </li> </ul>"},{"location":"api/#pysquared.hardware.light_sensor.manager","title":"manager","text":"<p>These managers interface with specific light sensor implementations.</p> <p>Modules:</p> <ul> <li> <code>veml6031x00</code>           \u2013            <p>VEML6031x00 light sensor manager for CircuitPython.</p> </li> <li> <code>veml7700</code>           \u2013            <p>This module defines the <code>VEML7700Manager</code> class, which provides a high-level interface</p> </li> </ul>"},{"location":"api/#pysquared.hardware.light_sensor.manager.veml6031x00","title":"veml6031x00","text":"<p>VEML6031x00 light sensor manager for CircuitPython.</p> <p>This module provides a CircuitPython implementation to interact with the VEML6031/VEML6030 ambient light sensor family using direct I2C register access. It mirrors the behavior of the Zephyr driver with support for single-measurement (active force) mode and data-ready polling.</p> Usage <p>logger = Logger() i2c = initialize_i2c_bus(logger, board.SCL, board.SDA, 100000) sensor = VEML6031x00Manager(logger, i2c) lux = sensor.get_lux()</p> <p>Classes:</p> <ul> <li> <code>VEML6031x00Manager</code>           \u2013            <p>Manages the VEML6031/VEML6030 ambient light sensor via I2C.</p> </li> </ul>"},{"location":"api/#pysquared.hardware.light_sensor.manager.veml6031x00.VEML6031x00Manager","title":"VEML6031x00Manager","text":"<pre><code>VEML6031x00Manager(logger: Logger, i2c: I2C | TCA9548A_Channel, address: int = _DEFAULT_I2C_ADDR, integration_time: int = IT_100MS, gain: int = GAIN_1, div4: int = SIZE_4_4, persistence: int = 0)\n</code></pre> <p>               Bases: <code>LightSensorProto</code></p> <p>Manages the VEML6031/VEML6030 ambient light sensor via I2C.</p> <p>Implements single-shot measurement using active force mode and polls the data-ready bit before reading ambient light and IR data. Converts counts to lux using the device's resolution matrix based on configuration.</p> <p>Parameters:</p> <ul> <li> <code>logger</code>               (<code>Logger</code>)           \u2013            <p>Logger to log messages.</p> </li> <li> <code>i2c</code>               (<code>I2C | TCA9548A_Channel</code>)           \u2013            <p>I2C bus or TCA channel the device is on.</p> </li> <li> <code>address</code>               (<code>int</code>, default:                   <code>_DEFAULT_I2C_ADDR</code> )           \u2013            <p>I2C address of the sensor (default 0x29).</p> </li> <li> <code>integration_time</code>               (<code>int</code>, default:                   <code>IT_100MS</code> )           \u2013            <p>One of <code>_It.*</code> indices (default 100ms).</p> </li> <li> <code>gain</code>               (<code>int</code>, default:                   <code>GAIN_1</code> )           \u2013            <p>One of <code>_Gain.*</code> indices (default 1x).</p> </li> <li> <code>div4</code>               (<code>int</code>, default:                   <code>SIZE_4_4</code> )           \u2013            <p>One of <code>_Div4.*</code> indices (default full size).</p> </li> <li> <code>persistence</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>Persistence setting for ambient-light channel (0 maps to 1 sample).</p> </li> </ul> <p>Methods:</p> <ul> <li> <code>get_light</code>             \u2013              <p>Perform a single measurement and return raw ambient-light counts.</p> </li> <li> <code>get_lux</code>             \u2013              <p>Perform a single measurement and return the light level in lux.</p> </li> <li> <code>reset</code>             \u2013              <p>Place device into shutdown briefly and then resume operation.</p> </li> </ul> <code></code> get_light <pre><code>get_light() -&gt; Light\n</code></pre> <p>Perform a single measurement and return raw ambient-light counts.</p> <p>Returns:</p> <ul> <li> <code>Light</code> (              <code>Light</code> )          \u2013            <p>Non-unit-specific reading (sensor counts).</p> </li> </ul> <code></code> get_lux <pre><code>get_lux() -&gt; Lux\n</code></pre> <p>Perform a single measurement and return the light level in lux.</p> <p>Returns:</p> <ul> <li> <code>Lux</code> (              <code>Lux</code> )          \u2013            <p>Light level in SI lux.</p> </li> </ul> <code></code> reset <pre><code>reset() -&gt; None\n</code></pre> <p>Place device into shutdown briefly and then resume operation.</p>"},{"location":"api/#pysquared.hardware.light_sensor.manager.veml7700","title":"veml7700","text":"<p>This module defines the <code>VEML7700Manager</code> class, which provides a high-level interface for interacting with the VEML7700 light sensor. It handles the initialization of the sensor and provides methods for reading light levels in various formats.</p> <p>Usage: <pre><code>logger = Logger()\ni2c = busio.I2C(board.SCL, board.SDA)\ni2c = initialize_i2c_bus(logger, board.SCL, board.SDA, 100000,)\nlight_sensor = VEML7700Manager(logger, i2c)\nlux_data = light_sensor.get_lux()\n</code></pre></p> <p>Classes:</p> <ul> <li> <code>VEML7700Manager</code>           \u2013            <p>Manages the VEML7700 ambient light sensor.</p> </li> </ul>"},{"location":"api/#pysquared.hardware.light_sensor.manager.veml7700.VEML7700Manager","title":"VEML7700Manager","text":"<pre><code>VEML7700Manager(logger: Logger, i2c: I2C | TCA9548A_Channel, integration_time: Literal[0, 1, 2, 3, 8, 12] = 12)\n</code></pre> <p>               Bases: <code>LightSensorProto</code></p> <p>Manages the VEML7700 ambient light sensor.</p> <p>Parameters:</p> <ul> <li> <code>logger</code>               (<code>Logger</code>)           \u2013            <p>The logger to use.</p> </li> <li> <code>i2c</code>               (<code>I2C | TCA9548A_Channel</code>)           \u2013            <p>The I2C bus connected to the chip.</p> </li> <li> <code>integration_time</code>               (<code>Literal[0, 1, 2, 3, 8, 12]</code>, default:                   <code>12</code> )           \u2013            <p>The integration time for the light sensor (default is 25ms). Integration times can be one of the following: - 12: 25ms - 8: 50ms - 0: 100ms - 1: 200ms - 2: 400ms - 3: 800ms</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>HardwareInitializationError</code>             \u2013            <p>If the light sensor fails to initialize.</p> </li> </ul> <p>Methods:</p> <ul> <li> <code>get_auto_lux</code>             \u2013              <p>Gets the auto lux reading of the sensor. This runs the sensor in auto mode</p> </li> <li> <code>get_light</code>             \u2013              <p>Gets the light reading of the sensor with default gain and integration time.</p> </li> <li> <code>get_lux</code>             \u2013              <p>Gets the light reading of the sensor with default gain and integration time.</p> </li> <li> <code>reset</code>             \u2013              <p>Resets the light sensor.</p> </li> </ul> <code></code> get_auto_lux <pre><code>get_auto_lux() -&gt; Lux\n</code></pre> <p>Gets the auto lux reading of the sensor. This runs the sensor in auto mode and returns the lux value by searching through the available gain and integration time combinations to find the best match.</p> <p>Returns:</p> <ul> <li> <code>Lux</code>           \u2013            <p>A Lux object containing the light level in SI lux.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>SensorReadingValueError</code>             \u2013            <p>If the reading returns an invalid value.</p> </li> <li> <code>SensorReadingUnknownError</code>             \u2013            <p>If an unknown error occurs while reading the sensor.</p> </li> </ul> <code></code> get_light <pre><code>get_light() -&gt; Light\n</code></pre> <p>Gets the light reading of the sensor with default gain and integration time.</p> <p>Returns:</p> <ul> <li> <code>Light</code>           \u2013            <p>A Light object containing a non-unit-specific light level reading.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>SensorReadingUnknownError</code>             \u2013            <p>If an unknown error occurs while reading the sensor.</p> </li> </ul> <code></code> get_lux <pre><code>get_lux() -&gt; Lux\n</code></pre> <p>Gets the light reading of the sensor with default gain and integration time.</p> <p>Returns:</p> <ul> <li> <code>Lux</code>           \u2013            <p>A Lux object containing the light level in SI lux.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>SensorReadingValueError</code>             \u2013            <p>If the reading returns an invalid value.</p> </li> <li> <code>SensorReadingUnknownError</code>             \u2013            <p>If an unknown error occurs while reading the sensor.</p> </li> </ul> <code></code> reset <pre><code>reset() -&gt; None\n</code></pre> <p>Resets the light sensor.</p>"},{"location":"api/#pysquared.hardware.load_switch","title":"load_switch","text":"<p>Load switch hardware interface.</p> <p>Modules:</p> <ul> <li> <code>manager</code>           \u2013            <p>Load switch manager class.</p> </li> </ul>"},{"location":"api/#pysquared.hardware.load_switch.manager","title":"manager","text":"<p>Load switch manager class.</p> <p>Modules:</p> <ul> <li> <code>loadswitch_manager</code>           \u2013            <p>This is a generic load switch manager for controlling power to components.</p> </li> </ul>"},{"location":"api/#pysquared.hardware.load_switch.manager.loadswitch_manager","title":"loadswitch_manager","text":"<p>This is a generic load switch manager for controlling power to components.</p> <p>Usage:</p> <p>from lib.pysquared.hardware.load_switch.manager.loadswitch_manager import LoadSwitchManager</p> <p>load_switch_0 = LoadSwitchManager(     FACE0_ENABLE, True )</p> <p>load_switch_0.enable_load() load_switch_0.disable_load() load_switch_0.reset_load() is_enabled = load_switch_0.is_enabled</p> <p>Classes:</p> <ul> <li> <code>LoadSwitchManager</code>           \u2013            <p>Manages load switch operations for any component or group of components that</p> </li> </ul>"},{"location":"api/#pysquared.hardware.load_switch.manager.loadswitch_manager.LoadSwitchManager","title":"LoadSwitchManager","text":"<pre><code>LoadSwitchManager(load_switch_pin: DigitalInOut, enable_high: bool = True)\n</code></pre> <p>               Bases: <code>LoadSwitchManagerProto</code></p> <p>Manages load switch operations for any component or group of components that has an independent load switch for power control.</p> <p>This class provides methods to enable, disable, and reset the load switch, as well as check its current state. It is designed to work with a digital pin that controls the load switch, allowing for high or low enable logic.</p> <p>:param enable_high: If True, load switch enables when pin is HIGH. If False, enables when LOW</p> <p>Methods:</p> <ul> <li> <code>disable_load</code>             \u2013              <p>Disables the load switch, cutting power.</p> </li> <li> <code>enable_load</code>             \u2013              <p>Enables the load switch, allowing power to flow.</p> </li> <li> <code>reset_load</code>             \u2013              <p>Reset the load switch by momentarily disabling then re-enabling it.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>is_enabled</code>               (<code>bool</code>)           \u2013            <p>Check if the load switch is currently enabled.</p> </li> </ul> <code></code> is_enabled <code>property</code> <pre><code>is_enabled: bool\n</code></pre> <p>Check if the load switch is currently enabled. :raises RuntimeError: If the load switch state cannot be read due to hardware issues :return: True if the load switch is enabled, False otherwise</p> <code></code> disable_load <pre><code>disable_load() -&gt; None\n</code></pre> <p>Disables the load switch, cutting power. :raises RuntimeError: If the load switch cannot be disabled due to hardware issues</p> <code></code> enable_load <pre><code>enable_load() -&gt; None\n</code></pre> <p>Enables the load switch, allowing power to flow. :raises RuntimeError: If the load switch cannot be enabled due to hardware issues</p> <code></code> reset_load <pre><code>reset_load() -&gt; None\n</code></pre> <p>Reset the load switch by momentarily disabling then re-enabling it. This method performs a momentary power cycle (0.1s) to reset the load switch and any connected components. Errors from underlying drivers are reraised. :raises RuntimeError: If the load switch cannot be reset due to hardware issues</p>"},{"location":"api/#pysquared.hardware.magnetometer","title":"magnetometer","text":"<p>This module provides an interface for controlling magnetormeters.</p> <p>Modules:</p> <ul> <li> <code>manager</code>           \u2013            <p>This module provides the managers for various magnetometer implementations</p> </li> </ul>"},{"location":"api/#pysquared.hardware.magnetometer.manager","title":"manager","text":"<p>This module provides the managers for various magnetometer implementations</p> <p>Modules:</p> <ul> <li> <code>lis2mdl</code>           \u2013            <p>This module defines the <code>LIS2MDLManager</code> class, which provides a high-level interface</p> </li> </ul>"},{"location":"api/#pysquared.hardware.magnetometer.manager.lis2mdl","title":"lis2mdl","text":"<p>This module defines the <code>LIS2MDLManager</code> class, which provides a high-level interface for interacting with the LIS2MDL magnetometer. It handles the initialization of the sensor and provides a method for reading the magnetic field vector.</p> <p>Usage: <pre><code>logger = Logger()\ni2c = busio.I2C(board.SCL, board.SDA)\nmagnetometer = LIS2MDLManager(logger, i2c)\nmag_field = magnetometer.get_magnetic_field()\n</code></pre></p> <p>Classes:</p> <ul> <li> <code>LIS2MDLManager</code>           \u2013            <p>Manages the LIS2MDL magnetometer.</p> </li> </ul>"},{"location":"api/#pysquared.hardware.magnetometer.manager.lis2mdl.LIS2MDLManager","title":"LIS2MDLManager","text":"<pre><code>LIS2MDLManager(logger: Logger, i2c: I2C)\n</code></pre> <p>               Bases: <code>MagnetometerProto</code></p> <p>Manages the LIS2MDL magnetometer.</p> <p>Parameters:</p> <ul> <li> <code>logger</code>               (<code>Logger</code>)           \u2013            <p>The logger to use.</p> </li> <li> <code>i2c</code>               (<code>I2C</code>)           \u2013            <p>The I2C bus connected to the chip.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>HardwareInitializationError</code>             \u2013            <p>If the magnetometer fails to initialize.</p> </li> </ul> <p>Methods:</p> <ul> <li> <code>get_magnetic_field</code>             \u2013              <p>Gets the magnetic field vector from the magnetometer.</p> </li> </ul> <code></code> get_magnetic_field <pre><code>get_magnetic_field() -&gt; Magnetic\n</code></pre> <p>Gets the magnetic field vector from the magnetometer.</p> <p>Returns:</p> <ul> <li> <code>Magnetic</code>           \u2013            <p>A Magnetic object containing the x, y, and z magnetic field values in micro-Tesla (uT)</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>SensorReadingTimeoutError</code>             \u2013            <p>If the reading times out.</p> </li> <li> <code>SensorReadingUnknownError</code>             \u2013            <p>If an unknown error occurs while reading the magnetometer.</p> </li> </ul>"},{"location":"api/#pysquared.hardware.power_monitor","title":"power_monitor","text":"<p>This module provides an interface for controlling power monitors.</p> <p>Modules:</p> <ul> <li> <code>manager</code>           \u2013            <p>This module provides the managers for various power monitor implementations</p> </li> </ul>"},{"location":"api/#pysquared.hardware.power_monitor.manager","title":"manager","text":"<p>This module provides the managers for various power monitor implementations</p> <p>Modules:</p> <ul> <li> <code>ina219</code>           \u2013            <p>This module defines the <code>INA219Manager</code> class, which provides a high-level interface</p> </li> </ul>"},{"location":"api/#pysquared.hardware.power_monitor.manager.ina219","title":"ina219","text":"<p>This module defines the <code>INA219Manager</code> class, which provides a high-level interface for interacting with the INA219 power monitor. It handles the initialization of the sensor and provides methods for reading bus voltage, shunt voltage, and current.</p> <p>Usage: <pre><code>logger = Logger()\ni2c = busio.I2C(board.SCL, board.SDA)\npower_monitor = INA219Manager(logger, i2c, 0x40)\nbus_voltage = power_monitor.get_bus_voltage()\nshunt_voltage = power_monitor.get_shunt_voltage()\ncurrent = power_monitor.get_current()\n</code></pre></p> <p>Classes:</p> <ul> <li> <code>INA219Manager</code>           \u2013            <p>Manages the INA219 power monitor.</p> </li> </ul>"},{"location":"api/#pysquared.hardware.power_monitor.manager.ina219.INA219Manager","title":"INA219Manager","text":"<pre><code>INA219Manager(logger: Logger, i2c: I2C, addr: int)\n</code></pre> <p>               Bases: <code>PowerMonitorProto</code></p> <p>Manages the INA219 power monitor.</p> <p>Parameters:</p> <ul> <li> <code>logger</code>               (<code>Logger</code>)           \u2013            <p>The logger to use.</p> </li> <li> <code>i2c</code>               (<code>I2C</code>)           \u2013            <p>The I2C bus connected to the chip.</p> </li> <li> <code>addr</code>               (<code>int</code>)           \u2013            <p>The I2C address of the INA219.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>HardwareInitializationError</code>             \u2013            <p>If the INA219 fails to initialize.</p> </li> </ul> <p>Methods:</p> <ul> <li> <code>get_bus_voltage</code>             \u2013              <p>Gets the bus voltage from the INA219.</p> </li> <li> <code>get_current</code>             \u2013              <p>Gets the current from the INA219.</p> </li> <li> <code>get_shunt_voltage</code>             \u2013              <p>Gets the shunt voltage from the INA219.</p> </li> </ul> <code></code> get_bus_voltage <pre><code>get_bus_voltage() -&gt; Voltage\n</code></pre> <p>Gets the bus voltage from the INA219.</p> <p>Returns:</p> <ul> <li> <code>Voltage</code>           \u2013            <p>A Voltage object containing the bus voltage in volts.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>SensorReadingUnknownError</code>             \u2013            <p>If an unknown error occurs while reading the light sensor.</p> </li> </ul> <code></code> get_current <pre><code>get_current() -&gt; Current\n</code></pre> <p>Gets the current from the INA219.</p> <p>Returns:</p> <ul> <li> <code>Current</code>           \u2013            <p>A Current object containing the current in milliamps (mA)</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>SensorReadingUnknownError</code>             \u2013            <p>If an unknown error occurs while reading the light sensor.</p> </li> </ul> <code></code> get_shunt_voltage <pre><code>get_shunt_voltage() -&gt; Voltage\n</code></pre> <p>Gets the shunt voltage from the INA219.</p> <p>Returns:</p> <ul> <li> <code>Voltage</code>           \u2013            <p>A Voltage object containing the shunt voltage in volts.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>SensorReadingUnknownError</code>             \u2013            <p>If an unknown error occurs while reading the light sensor.</p> </li> </ul>"},{"location":"api/#pysquared.hardware.radio","title":"radio","text":"<p>This module provides an interface for controlling radios.</p> <p>Modules:</p> <ul> <li> <code>manager</code>           \u2013            <p>This module provides the managers for various radio implementations.</p> </li> <li> <code>modulation</code>           \u2013            <p>This module defines the available radio modulation types.</p> </li> <li> <code>packetizer</code>           \u2013            <p>This package provides an interface for packetizing data for radio communication.</p> </li> </ul>"},{"location":"api/#pysquared.hardware.radio.manager","title":"manager","text":"<p>This module provides the managers for various radio implementations.</p> <p>Modules:</p> <ul> <li> <code>base</code>           \u2013            <p>This module provides a base class for radio managers.</p> </li> <li> <code>rfm9x</code>           \u2013            <p>This module provides a manager for RFM9x radios.</p> </li> <li> <code>sx126x</code>           \u2013            <p>This module provides a manager for SX126x radios.</p> </li> <li> <code>sx1280</code>           \u2013            <p>This module provides a manager for SX1280 radios.</p> </li> </ul>"},{"location":"api/#pysquared.hardware.radio.manager.base","title":"base","text":"<p>This module provides a base class for radio managers.</p> <p>This module defines the <code>BaseRadioManager</code> class, which serves as an abstract base class for all radio managers in the system. It provides common functionality and ensures that all radio managers adhere to a consistent interface.</p> <p>Classes:</p> <ul> <li> <code>BaseRadioManager</code>           \u2013            <p>Base class for radio managers (CircuitPython compatible).</p> </li> </ul>"},{"location":"api/#pysquared.hardware.radio.manager.base.BaseRadioManager","title":"BaseRadioManager","text":"<pre><code>BaseRadioManager(logger: Logger, radio_config: RadioConfig, **kwargs: object)\n</code></pre> <p>               Bases: <code>RadioProto</code></p> <p>Base class for radio managers (CircuitPython compatible).</p> <p>Parameters:</p> <ul> <li> <code>logger</code>               (<code>Logger</code>)           \u2013            <p>Logger instance for logging messages.</p> </li> <li> <code>radio_config</code>               (<code>RadioConfig</code>)           \u2013            <p>Radio configuration object.</p> </li> <li> <code>**kwargs</code>               (<code>object</code>, default:                   <code>{}</code> )           \u2013            <p>Hardware-specific arguments (e.g., spi, cs, rst).</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>HardwareInitializationError</code>             \u2013            <p>If the radio fails to initialize after retries.</p> </li> </ul> <p>Methods:</p> <ul> <li> <code>get_max_packet_size</code>             \u2013              <p>Gets the maximum packet size supported by the radio.</p> </li> <li> <code>get_modulation</code>             \u2013              <p>Gets the modulation mode from the initialized radio hardware.</p> </li> <li> <code>get_rssi</code>             \u2013              <p>Gets the RSSI of the last received packet.</p> </li> <li> <code>modify_config</code>             \u2013              <p>Modifies a specific radio configuration parameter.</p> </li> <li> <code>receive</code>             \u2013              <p>Receives data from the radio.</p> </li> <li> <code>send</code>             \u2013              <p>Sends data over the radio.</p> </li> <li> <code>set_modulation</code>             \u2013              <p>Requests a change in the radio modulation mode.</p> </li> </ul> <code></code> get_max_packet_size <pre><code>get_max_packet_size() -&gt; int\n</code></pre> <p>Gets the maximum packet size supported by the radio.</p> <p>Returns:</p> <ul> <li> <code>int</code>           \u2013            <p>The maximum packet size in bytes.</p> </li> </ul> <code></code> get_modulation <pre><code>get_modulation() -&gt; Type[RadioModulation]\n</code></pre> <p>Gets the modulation mode from the initialized radio hardware.</p> <p>Returns:</p> <ul> <li> <code>Type[RadioModulation]</code>           \u2013            <p>The current modulation mode of the hardware.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>NotImplementedError</code>             \u2013            <p>If not implemented by subclass.</p> </li> </ul> <code></code> get_rssi <pre><code>get_rssi() -&gt; int\n</code></pre> <p>Gets the RSSI of the last received packet.</p> <p>Returns:</p> <ul> <li> <code>int</code>           \u2013            <p>The RSSI of the last received packet.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>NotImplementedError</code>             \u2013            <p>If not implemented by subclass.</p> </li> </ul> <code></code> modify_config <pre><code>modify_config(key: str, value) -&gt; None\n</code></pre> <p>Modifies a specific radio configuration parameter.</p> <p>This method must be implemented by subclasses.</p> <p>Parameters:</p> <ul> <li> <code>key</code>               (<code>str</code>)           \u2013            <p>The configuration parameter key to modify.</p> </li> <li> <code>value</code>           \u2013            <p>The new value to set for the parameter.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>NotImplementedError</code>             \u2013            <p>If not implemented by subclass.</p> </li> </ul> <code></code> receive <pre><code>receive(timeout: Optional[int] = None) -&gt; bytes | None\n</code></pre> <p>Receives data from the radio.</p> <p>This method must be implemented by subclasses.</p> <p>Parameters:</p> <ul> <li> <code>timeout</code>               (<code>Optional[int]</code>, default:                   <code>None</code> )           \u2013            <p>Optional receive timeout in seconds. If None, use the default timeout.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bytes | None</code>           \u2013            <p>The received data as bytes, or None if no data was received.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>NotImplementedError</code>             \u2013            <p>If not implemented by subclass.</p> </li> <li> <code>Exception</code>             \u2013            <p>If receiving fails unexpectedly.</p> </li> </ul> <code></code> send <pre><code>send(data: bytes) -&gt; bool\n</code></pre> <p>Sends data over the radio.</p> <p>This method must be implemented by subclasses.</p> <p>Parameters:</p> <ul> <li> <code>data</code>               (<code>bytes</code>)           \u2013            <p>The data to send.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>True if the data was sent successfully, False otherwise.</p> </li> </ul> <code></code> set_modulation <pre><code>set_modulation(modulation: Type[RadioModulation]) -&gt; None\n</code></pre> <p>Requests a change in the radio modulation mode.</p> <p>This change might take effect immediately or after a reset, depending on implementation.</p> <p>Parameters:</p> <ul> <li> <code>modulation</code>               (<code>Type[RadioModulation]</code>)           \u2013            <p>The desired modulation mode.</p> </li> </ul>"},{"location":"api/#pysquared.hardware.radio.manager.rfm9x","title":"rfm9x","text":"<p>This module provides a manager for RFM9x radios.</p> <p>This module defines the <code>RFM9xManager</code> class, which implements the <code>RadioProto</code> interface for RFM9x radios. It handles the initialization and configuration of the radio, as well as sending and receiving data.</p> <p>Usage: <pre><code>logger = Logger()\nradio_config = RadioConfig()\nspi = busio.SPI(board.SCK, MOSI=board.MOSI, MISO=board.MISO)\ncs = digitalio.DigitalInOut(board.D5)\nreset = digitalio.DigitalInOut(board.D6)\nrfm9x_manager = RFM9xManager(logger, radio_config, spi, cs, reset)\nrfm9x_manager.send(b\"Hello world!\")\n</code></pre></p> <p>Classes:</p> <ul> <li> <code>RFM9xManager</code>           \u2013            <p>Manages RFM9x radios, implementing the RadioProto interface.</p> </li> </ul>"},{"location":"api/#pysquared.hardware.radio.manager.rfm9x.RFM9xManager","title":"RFM9xManager","text":"<pre><code>RFM9xManager(logger: Logger, radio_config: RadioConfig, spi: SPI, chip_select: DigitalInOut, reset: DigitalInOut)\n</code></pre> <p>               Bases: <code>BaseRadioManager</code>, <code>TemperatureSensorProto</code></p> <p>Manages RFM9x radios, implementing the RadioProto interface.</p> <p>Parameters:</p> <ul> <li> <code>logger</code>               (<code>Logger</code>)           \u2013            <p>Logger instance for logging messages.</p> </li> <li> <code>radio_config</code>               (<code>RadioConfig</code>)           \u2013            <p>Radio configuration object.</p> </li> <li> <code>spi</code>               (<code>SPI</code>)           \u2013            <p>The SPI bus connected to the chip.</p> </li> <li> <code>chip_select</code>               (<code>DigitalInOut</code>)           \u2013            <p>A DigitalInOut object connected to the chip's CS/chip select line.</p> </li> <li> <code>reset</code>               (<code>DigitalInOut</code>)           \u2013            <p>A DigitalInOut object connected to the chip's RST/reset line.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>HardwareInitializationError</code>             \u2013            <p>If the radio fails to initialize after retries.</p> </li> </ul> <p>Methods:</p> <ul> <li> <code>get_max_packet_size</code>             \u2013              <p>Gets the maximum packet size supported by the radio.</p> </li> <li> <code>get_modulation</code>             \u2013              <p>Gets the modulation mode from the initialized RFM9x radio.</p> </li> <li> <code>get_rssi</code>             \u2013              <p>Gets the RSSI of the last received packet.</p> </li> <li> <code>get_temperature</code>             \u2013              <p>Gets the temperature reading from the radio sensor.</p> </li> <li> <code>modify_config</code>             \u2013              <p>Modifies a specific radio configuration parameter.</p> </li> <li> <code>receive</code>             \u2013              <p>Receives data from the radio.</p> </li> <li> <code>send</code>             \u2013              <p>Sends data over the radio.</p> </li> <li> <code>set_modulation</code>             \u2013              <p>Requests a change in the radio modulation mode.</p> </li> </ul> <code></code> get_max_packet_size <pre><code>get_max_packet_size() -&gt; int\n</code></pre> <p>Gets the maximum packet size supported by the radio.</p> <p>Returns:</p> <ul> <li> <code>int</code>           \u2013            <p>The maximum packet size in bytes.</p> </li> </ul> <code></code> get_modulation <pre><code>get_modulation() -&gt; Type[RadioModulation]\n</code></pre> <p>Gets the modulation mode from the initialized RFM9x radio.</p> <p>Returns:</p> <ul> <li> <code>Type[RadioModulation]</code>           \u2013            <p>The current modulation mode of the hardware.</p> </li> </ul> <code></code> get_rssi <pre><code>get_rssi() -&gt; int\n</code></pre> <p>Gets the RSSI of the last received packet.</p> <p>Returns:</p> <ul> <li> <code>int</code>           \u2013            <p>The RSSI of the last received packet.</p> </li> </ul> <code></code> get_temperature <pre><code>get_temperature() -&gt; Temperature\n</code></pre> <p>Gets the temperature reading from the radio sensor.</p> <p>Returns:</p> <ul> <li> <code>Temperature</code>           \u2013            <p>A Temperature object containing the temperature in degrees Celsius.</p> </li> </ul> <p>Raises:     SensorReadingUnknownError: If an unknown error occurs while reading the temperature.</p> <code></code> modify_config <pre><code>modify_config(key: str, value) -&gt; None\n</code></pre> <p>Modifies a specific radio configuration parameter.</p> <p>Parameters:</p> <ul> <li> <code>key</code>               (<code>str</code>)           \u2013            <p>The configuration parameter key to modify.</p> </li> <li> <code>value</code>           \u2013            <p>The new value to set for the parameter.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If the key is not recognized or invalid for the current radio type.</p> </li> </ul> <code></code> receive <pre><code>receive(timeout: Optional[int] = None) -&gt; bytes | None\n</code></pre> <p>Receives data from the radio.</p> <p>Parameters:</p> <ul> <li> <code>timeout</code>               (<code>Optional[int]</code>, default:                   <code>None</code> )           \u2013            <p>Optional receive timeout in seconds. If None, use the default timeout.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bytes | None</code>           \u2013            <p>The received data as bytes, or None if no data was received.</p> </li> </ul> <code></code> send <pre><code>send(data: bytes) -&gt; bool\n</code></pre> <p>Sends data over the radio.</p> <p>This method must be implemented by subclasses.</p> <p>Parameters:</p> <ul> <li> <code>data</code>               (<code>bytes</code>)           \u2013            <p>The data to send.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>True if the data was sent successfully, False otherwise.</p> </li> </ul> <code></code> set_modulation <pre><code>set_modulation(modulation: Type[RadioModulation]) -&gt; None\n</code></pre> <p>Requests a change in the radio modulation mode.</p> <p>This change might take effect immediately or after a reset, depending on implementation.</p> <p>Parameters:</p> <ul> <li> <code>modulation</code>               (<code>Type[RadioModulation]</code>)           \u2013            <p>The desired modulation mode.</p> </li> </ul>"},{"location":"api/#pysquared.hardware.radio.manager.sx126x","title":"sx126x","text":"<p>This module provides a manager for SX126x radios.</p> <p>This module defines the <code>SX126xManager</code> class, which implements the <code>RadioProto</code> interface for SX126x radios. It handles the initialization and configuration of the radio, as well as sending and receiving data.</p> <p>Usage: <pre><code>logger = Logger()\nradio_config = RadioConfig()\nspi = busio.SPI(board.SCK, MOSI=board.MOSI, MISO=board.MISO)\ncs = digitalio.DigitalInOut(board.D5)\nirq = digitalio.DigitalInOut(board.D6)\nreset = digitalio.DigitalInOut(board.D7)\ngpio = digitalio.DigitalInOut(board.D8)\nsx126x_manager = SX126xManager(logger, radio_config, spi, cs, irq, reset, gpio)\nsx126x_manager.send(b\"Hello world!\")\n</code></pre></p> <p>Classes:</p> <ul> <li> <code>SX126xManager</code>           \u2013            <p>Manages SX126x radios, implementing the RadioProto interface.</p> </li> </ul>"},{"location":"api/#pysquared.hardware.radio.manager.sx126x.SX126xManager","title":"SX126xManager","text":"<pre><code>SX126xManager(logger: Logger, radio_config: RadioConfig, spi: SPI, chip_select: DigitalInOut, irq: DigitalInOut, reset: DigitalInOut, gpio: DigitalInOut)\n</code></pre> <p>               Bases: <code>BaseRadioManager</code></p> <p>Manages SX126x radios, implementing the RadioProto interface.</p> <p>Parameters:</p> <ul> <li> <code>logger</code>               (<code>Logger</code>)           \u2013            <p>Logger instance for logging messages.</p> </li> <li> <code>radio_config</code>               (<code>RadioConfig</code>)           \u2013            <p>Radio configuration object.</p> </li> <li> <code>spi</code>               (<code>SPI</code>)           \u2013            <p>The SPI bus connected to the chip.</p> </li> <li> <code>chip_select</code>               (<code>DigitalInOut</code>)           \u2013            <p>Chip select pin.</p> </li> <li> <code>irq</code>               (<code>DigitalInOut</code>)           \u2013            <p>Interrupt request pin.</p> </li> <li> <code>reset</code>               (<code>DigitalInOut</code>)           \u2013            <p>Reset pin.</p> </li> <li> <code>gpio</code>               (<code>DigitalInOut</code>)           \u2013            <p>General purpose IO pin (used by SX126x).</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>HardwareInitializationError</code>             \u2013            <p>If the radio fails to initialize after retries.</p> </li> </ul> <p>Methods:</p> <ul> <li> <code>get_max_packet_size</code>             \u2013              <p>Gets the maximum packet size supported by the radio.</p> </li> <li> <code>get_modulation</code>             \u2013              <p>Gets the modulation mode from the initialized SX126x radio.</p> </li> <li> <code>get_rssi</code>             \u2013              <p>Gets the RSSI of the last received packet.</p> </li> <li> <code>modify_config</code>             \u2013              <p>Modifies a specific radio configuration parameter.</p> </li> <li> <code>receive</code>             \u2013              <p>Receives data from the radio.</p> </li> <li> <code>send</code>             \u2013              <p>Sends data over the radio.</p> </li> <li> <code>set_modulation</code>             \u2013              <p>Requests a change in the radio modulation mode.</p> </li> </ul> <code></code> get_max_packet_size <pre><code>get_max_packet_size() -&gt; int\n</code></pre> <p>Gets the maximum packet size supported by the radio.</p> <p>Returns:</p> <ul> <li> <code>int</code>           \u2013            <p>The maximum packet size in bytes.</p> </li> </ul> <code></code> get_modulation <pre><code>get_modulation() -&gt; Type[RadioModulation]\n</code></pre> <p>Gets the modulation mode from the initialized SX126x radio.</p> <p>Returns:</p> <ul> <li> <code>Type[RadioModulation]</code>           \u2013            <p>The current modulation mode of the hardware.</p> </li> </ul> <code></code> get_rssi <pre><code>get_rssi() -&gt; int\n</code></pre> <p>Gets the RSSI of the last received packet.</p> <p>Returns:</p> <ul> <li> <code>int</code>           \u2013            <p>The RSSI of the last received packet.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>NotImplementedError</code>             \u2013            <p>If not implemented by subclass.</p> </li> </ul> <code></code> modify_config <pre><code>modify_config(key: str, value) -&gt; None\n</code></pre> <p>Modifies a specific radio configuration parameter.</p> <p>This method must be implemented by subclasses.</p> <p>Parameters:</p> <ul> <li> <code>key</code>               (<code>str</code>)           \u2013            <p>The configuration parameter key to modify.</p> </li> <li> <code>value</code>           \u2013            <p>The new value to set for the parameter.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>NotImplementedError</code>             \u2013            <p>If not implemented by subclass.</p> </li> </ul> <code></code> receive <pre><code>receive(timeout: Optional[int] = None) -&gt; bytes | None\n</code></pre> <p>Receives data from the radio.</p> <p>Parameters:</p> <ul> <li> <code>timeout</code>               (<code>Optional[int]</code>, default:                   <code>None</code> )           \u2013            <p>Optional receive timeout in seconds. If None, use the default timeout.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bytes | None</code>           \u2013            <p>The received data as bytes, or None if no data was received.</p> </li> </ul> <code></code> send <pre><code>send(data: bytes) -&gt; bool\n</code></pre> <p>Sends data over the radio.</p> <p>This method must be implemented by subclasses.</p> <p>Parameters:</p> <ul> <li> <code>data</code>               (<code>bytes</code>)           \u2013            <p>The data to send.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>True if the data was sent successfully, False otherwise.</p> </li> </ul> <code></code> set_modulation <pre><code>set_modulation(modulation: Type[RadioModulation]) -&gt; None\n</code></pre> <p>Requests a change in the radio modulation mode.</p> <p>This change might take effect immediately or after a reset, depending on implementation.</p> <p>Parameters:</p> <ul> <li> <code>modulation</code>               (<code>Type[RadioModulation]</code>)           \u2013            <p>The desired modulation mode.</p> </li> </ul>"},{"location":"api/#pysquared.hardware.radio.manager.sx1280","title":"sx1280","text":"<p>This module provides a manager for SX1280 radios.</p> <p>This module defines the <code>SX1280Manager</code> class, which implements the <code>RadioProto</code> interface for SX1280 radios. It handles the initialization and configuration of the radio, as well as sending and receiving data.</p> <p>Usage: <pre><code>logger = Logger()\nradio_config = RadioConfig()\nspi = busio.SPI(board.SCK, MOSI=board.MOSI, MISO=board.MISO)\ncs = digitalio.DigitalInOut(board.D5)\nreset = digitalio.DigitalInOut(board.D6)\nbusy = digitalio.DigitalInOut(board.D7)\ntxen = digitalio.DigitalInOut(board.D8)\nrxen = digitalio.DigitalInOut(board.D9)\nsx1280_manager = SX1280Manager(logger, radio_config, spi, cs, reset, busy, 2400.0, txen, rxen)\nsx1280_manager.send(b\"Hello world!\")\n</code></pre></p> <p>Classes:</p> <ul> <li> <code>SX1280Manager</code>           \u2013            <p>Manages SX1280 radios, implementing the RadioProto interface.</p> </li> </ul>"},{"location":"api/#pysquared.hardware.radio.manager.sx1280.SX1280Manager","title":"SX1280Manager","text":"<pre><code>SX1280Manager(logger: Logger, radio_config: RadioConfig, spi: SPI, chip_select: DigitalInOut, reset: DigitalInOut, busy: DigitalInOut, frequency: float, txen: DigitalInOut, rxen: DigitalInOut)\n</code></pre> <p>               Bases: <code>BaseRadioManager</code></p> <p>Manages SX1280 radios, implementing the RadioProto interface.</p> <p>Parameters:</p> <ul> <li> <code>logger</code>               (<code>Logger</code>)           \u2013            <p>Logger instance for logging messages.</p> </li> <li> <code>radio_config</code>               (<code>RadioConfig</code>)           \u2013            <p>Radio configuration object.</p> </li> <li> <code>spi</code>               (<code>SPI</code>)           \u2013            <p>The SPI bus connected to the chip.</p> </li> <li> <code>chip_select</code>               (<code>DigitalInOut</code>)           \u2013            <p>Chip select pin.</p> </li> <li> <code>reset</code>               (<code>DigitalInOut</code>)           \u2013            <p>Reset pin.</p> </li> <li> <code>busy</code>               (<code>DigitalInOut</code>)           \u2013            <p>Busy pin.</p> </li> <li> <code>frequency</code>               (<code>float</code>)           \u2013            <p>The frequency to operate on.</p> </li> <li> <code>txen</code>               (<code>DigitalInOut</code>)           \u2013            <p>Transmit enable pin.</p> </li> <li> <code>rxen</code>               (<code>DigitalInOut</code>)           \u2013            <p>Receive enable pin.</p> </li> </ul> <p>Methods:</p> <ul> <li> <code>get_max_packet_size</code>             \u2013              <p>Gets the maximum packet size supported by the radio.</p> </li> <li> <code>get_modulation</code>             \u2013              <p>Gets the modulation mode from the initialized SX1280 radio.</p> </li> <li> <code>get_rssi</code>             \u2013              <p>Gets the RSSI of the last received packet.</p> </li> <li> <code>modify_config</code>             \u2013              <p>Modifies a specific radio configuration parameter.</p> </li> <li> <code>receive</code>             \u2013              <p>Receives data from the radio.</p> </li> <li> <code>send</code>             \u2013              <p>Sends data over the radio.</p> </li> <li> <code>set_modulation</code>             \u2013              <p>Requests a change in the radio modulation mode.</p> </li> </ul> <code></code> get_max_packet_size <pre><code>get_max_packet_size() -&gt; int\n</code></pre> <p>Gets the maximum packet size supported by the radio.</p> <p>Returns:</p> <ul> <li> <code>int</code>           \u2013            <p>The maximum packet size in bytes.</p> </li> </ul> <code></code> get_modulation <pre><code>get_modulation() -&gt; Type[RadioModulation]\n</code></pre> <p>Gets the modulation mode from the initialized SX1280 radio.</p> <p>Returns:</p> <ul> <li> <code>Type[RadioModulation]</code>           \u2013            <p>The current modulation mode of the hardware.</p> </li> </ul> <code></code> get_rssi <pre><code>get_rssi() -&gt; int\n</code></pre> <p>Gets the RSSI of the last received packet.</p> <p>Returns:</p> <ul> <li> <code>int</code>           \u2013            <p>The RSSI of the last received packet.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>NotImplementedError</code>             \u2013            <p>If not implemented by subclass.</p> </li> </ul> <code></code> modify_config <pre><code>modify_config(key: str, value) -&gt; None\n</code></pre> <p>Modifies a specific radio configuration parameter.</p> <p>This method must be implemented by subclasses.</p> <p>Parameters:</p> <ul> <li> <code>key</code>               (<code>str</code>)           \u2013            <p>The configuration parameter key to modify.</p> </li> <li> <code>value</code>           \u2013            <p>The new value to set for the parameter.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>NotImplementedError</code>             \u2013            <p>If not implemented by subclass.</p> </li> </ul> <code></code> receive <pre><code>receive(timeout: Optional[int] = None) -&gt; bytes | None\n</code></pre> <p>Receives data from the radio.</p> <p>Parameters:</p> <ul> <li> <code>timeout</code>               (<code>Optional[int]</code>, default:                   <code>None</code> )           \u2013            <p>Optional receive timeout in seconds. If None, use the default timeout.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bytes | None</code>           \u2013            <p>The received data as bytes, or None if no data was received.</p> </li> </ul> <code></code> send <pre><code>send(data: bytes) -&gt; bool\n</code></pre> <p>Sends data over the radio.</p> <p>This method must be implemented by subclasses.</p> <p>Parameters:</p> <ul> <li> <code>data</code>               (<code>bytes</code>)           \u2013            <p>The data to send.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>True if the data was sent successfully, False otherwise.</p> </li> </ul> <code></code> set_modulation <pre><code>set_modulation(modulation: Type[RadioModulation]) -&gt; None\n</code></pre> <p>Requests a change in the radio modulation mode.</p> <p>This change might take effect immediately or after a reset, depending on implementation.</p> <p>Parameters:</p> <ul> <li> <code>modulation</code>               (<code>Type[RadioModulation]</code>)           \u2013            <p>The desired modulation mode.</p> </li> </ul>"},{"location":"api/#pysquared.hardware.radio.modulation","title":"modulation","text":"<p>This module defines the available radio modulation types.</p> <p>This module provides a set of classes that represent the different radio modulation types that can be used by the radio hardware. These classes are used to configure the radio and to identify the current modulation type.</p> <p>Classes:</p> <ul> <li> <code>FSK</code>           \u2013            <p>Represents the FSK modulation mode.</p> </li> <li> <code>LoRa</code>           \u2013            <p>Represents the LoRa modulation mode.</p> </li> <li> <code>RadioModulation</code>           \u2013            <p>Base class for radio modulation modes.</p> </li> </ul>"},{"location":"api/#pysquared.hardware.radio.modulation.FSK","title":"FSK","text":"<p>               Bases: <code>RadioModulation</code></p> <p>Represents the FSK modulation mode.</p>"},{"location":"api/#pysquared.hardware.radio.modulation.LoRa","title":"LoRa","text":"<p>               Bases: <code>RadioModulation</code></p> <p>Represents the LoRa modulation mode.</p>"},{"location":"api/#pysquared.hardware.radio.modulation.RadioModulation","title":"RadioModulation","text":"<p>Base class for radio modulation modes.</p>"},{"location":"api/#pysquared.hardware.radio.packetizer","title":"packetizer","text":"<p>This package provides an interface for packetizing data for radio communication.</p> <p>Modules:</p> <ul> <li> <code>packet_manager</code>           \u2013            <p>This module provides a PacketManager for sending and receiving data over a radio.</p> </li> </ul>"},{"location":"api/#pysquared.hardware.radio.packetizer.packet_manager","title":"packet_manager","text":"<p>This module provides a PacketManager for sending and receiving data over a radio.</p> <p>This module handles the fragmentation and reassembly of data into packets for transmission over a radio. It also provides methods for sending and receiving acknowledgments.</p> <p>Usage: <pre><code>logger = Logger()\nradio = RFM9xManager(logger, radio_config, spi, cs, reset)\npacket_manager = PacketManager(logger, radio, \"my_license_key\")\npacket_manager.send(b\"Hello world!\")\nreceived_data = packet_manager.listen()\n</code></pre></p> <p>Classes:</p> <ul> <li> <code>PacketManager</code>           \u2013            <p>Manages the sending and receiving of data packets over a radio.</p> </li> </ul>"},{"location":"api/#pysquared.hardware.radio.packetizer.packet_manager.PacketManager","title":"PacketManager","text":"<pre><code>PacketManager(logger: Logger, radio: RadioProto, license: str, message_counter: Counter, send_delay: float = 0.2)\n</code></pre> <p>Manages the sending and receiving of data packets over a radio.</p> <p>Parameters:</p> <ul> <li> <code>logger</code>               (<code>Logger</code>)           \u2013            <p>The logger to use.</p> </li> <li> <code>radio</code>               (<code>RadioProto</code>)           \u2013            <p>The radio instance to use for communication.</p> </li> <li> <code>license</code>               (<code>str</code>)           \u2013            <p>The license key for sending data.</p> </li> <li> <code>send_delay</code>               (<code>float</code>, default:                   <code>0.2</code> )           \u2013            <p>The delay between sending packets.</p> </li> </ul> <p>Methods:</p> <ul> <li> <code>get_last_rssi</code>             \u2013              <p>Gets the RSSI of the last received packet.</p> </li> <li> <code>listen</code>             \u2013              <p>Listens for data from the radio.</p> </li> <li> <code>send</code>             \u2013              <p>Sends data over the radio.</p> </li> <li> <code>send_acknowledgement</code>             \u2013              <p>Sends an acknowledgment to the radio.</p> </li> </ul> <code></code> get_last_rssi <pre><code>get_last_rssi() -&gt; int\n</code></pre> <p>Gets the RSSI of the last received packet.</p> <p>Returns:</p> <ul> <li> <code>int</code>           \u2013            <p>The RSSI of the last received packet.</p> </li> </ul> <code></code> listen <pre><code>listen(timeout: Optional[int] = None) -&gt; bytes | None\n</code></pre> <p>Listens for data from the radio.</p> <p>Parameters:</p> <ul> <li> <code>timeout</code>               (<code>Optional[int]</code>, default:                   <code>None</code> )           \u2013            <p>Optional receive timeout in seconds. If None, use the default timeout.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bytes | None</code>           \u2013            <p>The received data as bytes, or None if no data was received.</p> </li> </ul> <code></code> send <pre><code>send(data: bytes) -&gt; bool\n</code></pre> <p>Sends data over the radio.</p> <p>Parameters:</p> <ul> <li> <code>data</code>               (<code>bytes</code>)           \u2013            <p>The data to send.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>True if the data was sent successfully, False otherwise.</p> </li> </ul> <code></code> send_acknowledgement <pre><code>send_acknowledgement() -&gt; None\n</code></pre> <p>Sends an acknowledgment to the radio.</p>"},{"location":"api/#pysquared.hardware.temperature_sensor","title":"temperature_sensor","text":"<p>This module provides temperature sensor hardware managers.</p> <p>Modules:</p> <ul> <li> <code>manager</code>           \u2013            <p>This module provides temperature sensor manager implementations.</p> </li> </ul>"},{"location":"api/#pysquared.hardware.temperature_sensor.manager","title":"manager","text":"<p>This module provides temperature sensor manager implementations.</p> <p>Modules:</p> <ul> <li> <code>mcp9808</code>           \u2013            <p>This module defines the <code>MCP9808Manager</code> class, which provides a high-level interface</p> </li> </ul>"},{"location":"api/#pysquared.hardware.temperature_sensor.manager.mcp9808","title":"mcp9808","text":"<p>This module defines the <code>MCP9808Manager</code> class, which provides a high-level interface for interacting with the MCP9808 temperature sensor. It handles the initialization of the sensor and provides methods for reading temperature data.</p> <p>Usage: <pre><code>logger = Logger()\ni2c = busio.I2C(board.SCL, board.SDA)\ntemp_sensor = MCP9808Manager(logger, i2c, 0x18)\ntemperature = temp_sensor.get_temperature()\n</code></pre></p> <p>Classes:</p> <ul> <li> <code>MCP9808Manager</code>           \u2013            <p>Manages the MCP9808 temperature sensor.</p> </li> </ul>"},{"location":"api/#pysquared.hardware.temperature_sensor.manager.mcp9808.MCP9808Manager","title":"MCP9808Manager","text":"<pre><code>MCP9808Manager(logger: Logger, i2c: I2C | TCA9548A_Channel, addr: int)\n</code></pre> <p>               Bases: <code>TemperatureSensorProto</code></p> <p>Manages the MCP9808 temperature sensor.</p> <p>Parameters:</p> <ul> <li> <code>logger</code>               (<code>Logger</code>)           \u2013            <p>The logger to use.</p> </li> <li> <code>i2c</code>               (<code>I2C | TCA9548A_Channel</code>)           \u2013            <p>The I2C bus connected to the chip.</p> </li> <li> <code>addr</code>               (<code>int</code>)           \u2013            <p>The I2C address of the MCP9808. Defaults to 0x18.</p> </li> <li> <code>resolution</code>           \u2013            <p>The resolution of the temperature sensor. Defaults to 1 which is 0.25 degrees celsius.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>HardwareInitializationError</code>             \u2013            <p>If the MCP9808 fails to initialize.</p> </li> </ul> <p>Methods:</p> <ul> <li> <code>get_temperature</code>             \u2013              <p>Gets the temperature reading from the MCP9808.</p> </li> </ul> <code></code> get_temperature <pre><code>get_temperature() -&gt; Temperature\n</code></pre> <p>Gets the temperature reading from the MCP9808.</p> <p>Returns:</p> <ul> <li> <code>Temperature</code>           \u2013            <p>A Temperature object containing the temperature in degrees Celsius.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>SensorReadingUnknownError</code>             \u2013            <p>If an unknown error occurs while reading the temperature.</p> </li> </ul>"},{"location":"api/#pysquared.logger","title":"logger","text":"<p>This module provides a Logger class for handling logging messages.</p> <p>The Logger class supports different severity levels, colorized output, and error counting. Logs are formatted as JSON and can be output to the console.</p> <p>Usage: <pre><code>error_counter = Counter(nvm)\nlogger = Logger(error_counter, log_level=LogLevel.INFO, colorized=True)\nlogger.info(\"This is an informational message.\")\nlogger.error(\"This is an error message.\", err=Exception(\"Something went wrong.\"))\n</code></pre></p> <p>Classes:</p> <ul> <li> <code>LogLevel</code>           \u2013            <p>Defines log level constants for Logger.</p> </li> <li> <code>Logger</code>           \u2013            <p>Handles logging messages with different severity levels.</p> </li> </ul>"},{"location":"api/#pysquared.logger.LogLevel","title":"LogLevel","text":"<p>Defines log level constants for Logger.</p>"},{"location":"api/#pysquared.logger.Logger","title":"Logger","text":"<pre><code>Logger(error_counter: Counter, log_level: int = NOTSET, colorized: bool = False)\n</code></pre> <p>Handles logging messages with different severity levels.</p> <p>Parameters:</p> <p>Methods:</p> <ul> <li> <code>critical</code>             \u2013              <p>Log a message with severity level CRITICAL.</p> </li> <li> <code>debug</code>             \u2013              <p>Log a message with severity level DEBUG.</p> </li> <li> <code>error</code>             \u2013              <p>Log a message with severity level ERROR.</p> </li> <li> <code>get_error_count</code>             \u2013              <p>Returns the current error count.</p> </li> <li> <code>info</code>             \u2013              <p>Log a message with severity level INFO.</p> </li> <li> <code>set_log_dir</code>             \u2013              <p>Sets the log directory for file logging.</p> </li> <li> <code>warning</code>             \u2013              <p>Log a message with severity level WARNING.</p> </li> </ul>"},{"location":"api/#pysquared.logger.Logger(error_counter)","title":"<code>error_counter</code>","text":"(<code>Counter</code>)           \u2013            <p>Counter for error occurrences.</p>"},{"location":"api/#pysquared.logger.Logger(log_level)","title":"<code>log_level</code>","text":"(<code>int</code>, default:                   <code>NOTSET</code> )           \u2013            <p>Initial log level.</p>"},{"location":"api/#pysquared.logger.Logger(colorized)","title":"<code>colorized</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to colorize output.</p>"},{"location":"api/#pysquared.logger.Logger.critical","title":"critical","text":"<pre><code>critical(message: str, err: Exception, **kwargs: object) -&gt; None\n</code></pre> <p>Log a message with severity level CRITICAL.</p> <p>Parameters:</p>"},{"location":"api/#pysquared.logger.Logger.critical(message)","title":"<code>message</code>","text":"(<code>str</code>)           \u2013            <p>The log message.</p>"},{"location":"api/#pysquared.logger.Logger.critical(err)","title":"<code>err</code>","text":"(<code>Exception</code>)           \u2013            <p>The exception to log.</p>"},{"location":"api/#pysquared.logger.Logger.critical(**kwargs)","title":"<code>**kwargs</code>","text":"(<code>object</code>, default:                   <code>{}</code> )           \u2013            <p>Additional key/value pairs to include in the log.</p>"},{"location":"api/#pysquared.logger.Logger.debug","title":"debug","text":"<pre><code>debug(message: str, **kwargs: object) -&gt; None\n</code></pre> <p>Log a message with severity level DEBUG.</p> <p>Parameters:</p>"},{"location":"api/#pysquared.logger.Logger.debug(message)","title":"<code>message</code>","text":"(<code>str</code>)           \u2013            <p>The log message.</p>"},{"location":"api/#pysquared.logger.Logger.debug(**kwargs)","title":"<code>**kwargs</code>","text":"(<code>object</code>, default:                   <code>{}</code> )           \u2013            <p>Additional key/value pairs to include in the log.</p>"},{"location":"api/#pysquared.logger.Logger.error","title":"error","text":"<pre><code>error(message: str, err: Exception, **kwargs: object) -&gt; None\n</code></pre> <p>Log a message with severity level ERROR.</p> <p>Parameters:</p>"},{"location":"api/#pysquared.logger.Logger.error(message)","title":"<code>message</code>","text":"(<code>str</code>)           \u2013            <p>The log message.</p>"},{"location":"api/#pysquared.logger.Logger.error(err)","title":"<code>err</code>","text":"(<code>Exception</code>)           \u2013            <p>The exception to log.</p>"},{"location":"api/#pysquared.logger.Logger.error(**kwargs)","title":"<code>**kwargs</code>","text":"(<code>object</code>, default:                   <code>{}</code> )           \u2013            <p>Additional key/value pairs to include in the log.</p>"},{"location":"api/#pysquared.logger.Logger.get_error_count","title":"get_error_count","text":"<pre><code>get_error_count() -&gt; int\n</code></pre> <p>Returns the current error count.</p> <p>Returns:</p> <ul> <li> <code>int</code> (              <code>int</code> )          \u2013            <p>The number of errors logged.</p> </li> </ul>"},{"location":"api/#pysquared.logger.Logger.info","title":"info","text":"<pre><code>info(message: str, **kwargs: object) -&gt; None\n</code></pre> <p>Log a message with severity level INFO.</p> <p>Parameters:</p>"},{"location":"api/#pysquared.logger.Logger.info(message)","title":"<code>message</code>","text":"(<code>str</code>)           \u2013            <p>The log message.</p>"},{"location":"api/#pysquared.logger.Logger.info(**kwargs)","title":"<code>**kwargs</code>","text":"(<code>object</code>, default:                   <code>{}</code> )           \u2013            <p>Additional key/value pairs to include in the log.</p>"},{"location":"api/#pysquared.logger.Logger.set_log_dir","title":"set_log_dir","text":"<pre><code>set_log_dir(log_dir: str) -&gt; None\n</code></pre> <p>Sets the log directory for file logging.</p> <p>Parameters:</p> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If the provided path is not a valid directory.</p> </li> </ul>"},{"location":"api/#pysquared.logger.Logger.set_log_dir(log_dir)","title":"<code>log_dir</code>","text":"(<code>str</code>)           \u2013            <p>Directory to save log files.</p>"},{"location":"api/#pysquared.logger.Logger.warning","title":"warning","text":"<pre><code>warning(message: str, **kwargs: object) -&gt; None\n</code></pre> <p>Log a message with severity level WARNING.</p> <p>Parameters:</p>"},{"location":"api/#pysquared.logger.Logger.warning(message)","title":"<code>message</code>","text":"(<code>str</code>)           \u2013            <p>The log message.</p>"},{"location":"api/#pysquared.logger.Logger.warning(**kwargs)","title":"<code>**kwargs</code>","text":"(<code>object</code>, default:                   <code>{}</code> )           \u2013            <p>Additional key/value pairs to include in the log.</p>"},{"location":"api/#pysquared.nvm","title":"nvm","text":"<p>The NVM package is a collection of functionality that interacts with non-volatile memory</p> <p>Modules:</p> <ul> <li> <code>counter</code>           \u2013            <p>This module provides the Counter class for managing 8-bit counters stored in</p> </li> <li> <code>flag</code>           \u2013            <p>This module provides the Flag class for managing boolean flags stored in</p> </li> </ul>"},{"location":"api/#pysquared.nvm.counter","title":"counter","text":"<p>This module provides the Counter class for managing 8-bit counters stored in non-volatile memory (NVM) on CircuitPython devices.</p> <p>Classes:</p> <ul> <li> <code>Counter</code>           \u2013            <p>Counter class for managing 8-bit counters stored in non-volatile memory.</p> </li> </ul>"},{"location":"api/#pysquared.nvm.counter.Counter","title":"Counter","text":"<pre><code>Counter(index: int)\n</code></pre> <p>Counter class for managing 8-bit counters stored in non-volatile memory.</p> <p>Attributes:</p> <ul> <li> <code>_index</code>               (<code>int</code>)           \u2013            <p>The index of the counter in the NVM datastore.</p> </li> <li> <code>_datastore</code>               (<code>ByteArray</code>)           \u2013            <p>The NVM datastore.</p> </li> </ul> <p>Parameters:</p> <ul> <li> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If NVM is not available.</p> </li> </ul> <p>Methods:</p> <ul> <li> <code>get</code>             \u2013              <p>Returns the value of the counter.</p> </li> <li> <code>get_name</code>             \u2013              <p>get_name returns the name of the counter</p> </li> <li> <code>increment</code>             \u2013              <p>Increases the counter by one, with 8-bit rollover.</p> </li> </ul>"},{"location":"api/#pysquared.nvm.counter.Counter(index)","title":"<code>index</code>","text":"(<code>int</code>)           \u2013            <p>The index of the counter in the datastore.</p>"},{"location":"api/#pysquared.nvm.counter.Counter.get","title":"get","text":"<pre><code>get() -&gt; int\n</code></pre> <p>Returns the value of the counter.</p> <p>Returns:</p> <ul> <li> <code>int</code> (              <code>int</code> )          \u2013            <p>The current value of the counter.</p> </li> </ul>"},{"location":"api/#pysquared.nvm.counter.Counter.get_name","title":"get_name","text":"<pre><code>get_name() -&gt; str\n</code></pre> <p>get_name returns the name of the counter</p>"},{"location":"api/#pysquared.nvm.counter.Counter.increment","title":"increment","text":"<pre><code>increment() -&gt; None\n</code></pre> <p>Increases the counter by one, with 8-bit rollover.</p>"},{"location":"api/#pysquared.nvm.flag","title":"flag","text":"<p>This module provides the Flag class for managing boolean flags stored in non-volatile memory (NVM) on CircuitPython devices.</p> <p>Classes:</p> <ul> <li> <code>Flag</code>           \u2013            <p>Flag class for managing boolean flags stored in non-volatile memory.</p> </li> </ul>"},{"location":"api/#pysquared.nvm.flag.Flag","title":"Flag","text":"<pre><code>Flag(index: int, bit_index: int)\n</code></pre> <p>Flag class for managing boolean flags stored in non-volatile memory.</p> <p>Attributes:</p> <ul> <li> <code>_index</code>               (<code>int</code>)           \u2013            <p>The index of the flag (byte) in the NVM datastore.</p> </li> <li> <code>_bit</code>               (<code>int</code>)           \u2013            <p>The bit index within the byte.</p> </li> <li> <code>_datastore</code>               (<code>ByteArray</code>)           \u2013            <p>The NVM datastore.</p> </li> <li> <code>_bit_mask</code>               (<code>int</code>)           \u2013            <p>Bitmask for the flag's bit position.</p> </li> </ul> <p>Parameters:</p> <ul> <li> </li> <li> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If NVM is not available.</p> </li> </ul> <p>Methods:</p> <ul> <li> <code>get</code>             \u2013              <p>Returns the value of the flag.</p> </li> <li> <code>get_name</code>             \u2013              <p>get_name returns the name of the flag</p> </li> <li> <code>toggle</code>             \u2013              <p>Sets or clears the flag value.</p> </li> </ul>"},{"location":"api/#pysquared.nvm.flag.Flag(index)","title":"<code>index</code>","text":"(<code>int</code>)           \u2013            <p>The index of the flag (byte) in the datastore.</p>"},{"location":"api/#pysquared.nvm.flag.Flag(bit_index)","title":"<code>bit_index</code>","text":"(<code>int</code>)           \u2013            <p>The index of the bit within the byte.</p>"},{"location":"api/#pysquared.nvm.flag.Flag.get","title":"get","text":"<pre><code>get() -&gt; bool\n</code></pre> <p>Returns the value of the flag.</p> <p>Returns:</p> <ul> <li> <code>bool</code> (              <code>bool</code> )          \u2013            <p>The current value of the flag.</p> </li> </ul>"},{"location":"api/#pysquared.nvm.flag.Flag.get_name","title":"get_name","text":"<pre><code>get_name() -&gt; str\n</code></pre> <p>get_name returns the name of the flag</p>"},{"location":"api/#pysquared.nvm.flag.Flag.toggle","title":"toggle","text":"<pre><code>toggle(value: bool) -&gt; None\n</code></pre> <p>Sets or clears the flag value.</p> <p>Parameters:</p>"},{"location":"api/#pysquared.nvm.flag.Flag.toggle(value)","title":"<code>value</code>","text":"(<code>bool</code>)           \u2013            <p>If True, sets the flag; if False, clears the flag.</p>"},{"location":"api/#pysquared.power_health","title":"power_health","text":"<p>This module provides a PowerHealth class for monitoring the power system.</p> <p>The PowerHealth class checks the battery voltage and current draw to determine the overall health of the power system. It returns one of four states: NOMINAL, DEGRADED, CRITICAL, or UNKNOWN.</p> <p>Usage: <pre><code>logger = Logger()\nconfig = Config(\"config.json\")\npower_monitor = INA219Manager(logger, i2c)\npower_health = PowerHealth(logger, config, power_monitor)\nhealth_status = power_health.get()\n</code></pre></p> <p>Classes:</p> <ul> <li> <code>CRITICAL</code>           \u2013            <p>Represents a critical power health state.</p> </li> <li> <code>DEGRADED</code>           \u2013            <p>Represents a degraded power health state.</p> </li> <li> <code>NOMINAL</code>           \u2013            <p>Represents a nominal power health state.</p> </li> <li> <code>PowerHealth</code>           \u2013            <p>Monitors the power system and determines its health.</p> </li> <li> <code>State</code>           \u2013            <p>Base class for power health states.</p> </li> <li> <code>UNKNOWN</code>           \u2013            <p>Represents an unknown power health state.</p> </li> </ul>"},{"location":"api/#pysquared.power_health.CRITICAL","title":"CRITICAL","text":"<p>               Bases: <code>State</code></p> <p>Represents a critical power health state.</p>"},{"location":"api/#pysquared.power_health.DEGRADED","title":"DEGRADED","text":"<p>               Bases: <code>State</code></p> <p>Represents a degraded power health state.</p>"},{"location":"api/#pysquared.power_health.NOMINAL","title":"NOMINAL","text":"<p>               Bases: <code>State</code></p> <p>Represents a nominal power health state.</p>"},{"location":"api/#pysquared.power_health.PowerHealth","title":"PowerHealth","text":"<pre><code>PowerHealth(logger: Logger, config: Config, power_monitor: PowerMonitorProto)\n</code></pre> <p>Monitors the power system and determines its health.</p> <p>Parameters:</p> <p>Methods:</p> <ul> <li> <code>get</code>             \u2013              <p>Gets the current power health.</p> </li> </ul>"},{"location":"api/#pysquared.power_health.PowerHealth(logger)","title":"<code>logger</code>","text":"(<code>Logger</code>)           \u2013            <p>The logger to use.</p>"},{"location":"api/#pysquared.power_health.PowerHealth(config)","title":"<code>config</code>","text":"(<code>Config</code>)           \u2013            <p>The configuration to use.</p>"},{"location":"api/#pysquared.power_health.PowerHealth(power_monitor)","title":"<code>power_monitor</code>","text":"(<code>PowerMonitorProto</code>)           \u2013            <p>The power monitor to use.</p>"},{"location":"api/#pysquared.power_health.PowerHealth.get","title":"get","text":"<pre><code>get() -&gt; NOMINAL | DEGRADED | CRITICAL | UNKNOWN\n</code></pre> <p>Gets the current power health.</p> <p>Returns:</p> <ul> <li> <code>NOMINAL | DEGRADED | CRITICAL | UNKNOWN</code>           \u2013            <p>The current power health state.</p> </li> </ul>"},{"location":"api/#pysquared.power_health.State","title":"State","text":"<p>Base class for power health states.</p>"},{"location":"api/#pysquared.power_health.UNKNOWN","title":"UNKNOWN","text":"<p>               Bases: <code>State</code></p> <p>Represents an unknown power health state.</p>"},{"location":"api/#pysquared.protos","title":"protos","text":"<p>This module defines hardware agnostic protocols for accessing devices with certain features. This allows for flexibility in the design of the system, enabling the use of different hardware implementations without changing the code that uses them.</p> <p>CircuitPython does not support Protocols directly, but these classes can still be used to define an interface for type checking and ensuring multi-device compatibility.</p> <p>https://docs.python.org/3/library/typing.html#typing.Protocol</p> <p>Modules:</p> <ul> <li> <code>burnwire</code>           \u2013            <p>This protocol specifies the interface that any burnwire implementation must adhere</p> </li> <li> <code>imu</code>           \u2013            <p>This protocol specifies the interface that any IMU implementation must adhere to,</p> </li> <li> <code>light_sensor</code>           \u2013            <p>This protocol specifies the interface that any light sensor implementation</p> </li> <li> <code>loadswitch</code>           \u2013            <p>Load switch manager protocol for generic components.</p> </li> <li> <code>magnetometer</code>           \u2013            <p>This protocol specifies the interface that any magnetometer implementation must</p> </li> <li> <code>power_monitor</code>           \u2013            <p>This protocol specifies the interface that any power monitor implementation must</p> </li> <li> <code>radio</code>           \u2013            <p>This protocol specifies the interface that any radio implementation must adhere</p> </li> <li> <code>reading</code>           \u2013            <p>This protocol specifies the interface that any sensor reading protocol implementation must</p> </li> <li> <code>rtc</code>           \u2013            <p>This protocol specifies the interface that any Real-Time Clock (RTC) implementation</p> </li> <li> <code>temperature_sensor</code>           \u2013            <p>This protocol specifies the interface that any temperature sensor implementation</p> </li> </ul>"},{"location":"api/#pysquared.protos.burnwire","title":"burnwire","text":"<p>This protocol specifies the interface that any burnwire implementation must adhere to, ensuring consistent behavior across different burnwire hardware.</p> <p>Classes:</p> <ul> <li> <code>BurnwireProto</code>           \u2013            <p>Protocol defining the interface for a burnwire port.</p> </li> </ul>"},{"location":"api/#pysquared.protos.burnwire.BurnwireProto","title":"BurnwireProto","text":"<p>Protocol defining the interface for a burnwire port.</p> <p>Methods:</p> <ul> <li> <code>burn</code>             \u2013              <p>Fires the burnwire for a specified amount of time.</p> </li> </ul>"},{"location":"api/#pysquared.protos.burnwire.BurnwireProto.burn","title":"burn","text":"<pre><code>burn(timeout_duration: float) -&gt; bool\n</code></pre> <p>Fires the burnwire for a specified amount of time.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>True if the burn occurred successfully, False otherwise.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>Exception</code>             \u2013            <p>If there is an error toggling the burnwire pins.</p> </li> </ul>"},{"location":"api/#pysquared.protos.burnwire.BurnwireProto.burn(timeout_duration)","title":"<code>timeout_duration</code>","text":"(<code>float</code>)           \u2013            <p>The maximum amount of time to keep the burnwire on.</p>"},{"location":"api/#pysquared.protos.imu","title":"imu","text":"<p>This protocol specifies the interface that any IMU implementation must adhere to, ensuring consistent behavior across different IMU hardware.</p> <p>Classes:</p> <ul> <li> <code>IMUProto</code>           \u2013            <p>Protocol defining the interface for an Inertial Measurement Unit (IMU).</p> </li> </ul>"},{"location":"api/#pysquared.protos.imu.IMUProto","title":"IMUProto","text":"<p>Protocol defining the interface for an Inertial Measurement Unit (IMU).</p> <p>Methods:</p> <ul> <li> <code>get_acceleration</code>             \u2013              <p>Gets the acceleration data from the inertial measurement unit.</p> </li> <li> <code>get_angular_velocity</code>             \u2013              <p>Gets the angular velocity from the inertial measurement unit.</p> </li> </ul>"},{"location":"api/#pysquared.protos.imu.IMUProto.get_acceleration","title":"get_acceleration","text":"<pre><code>get_acceleration() -&gt; Acceleration\n</code></pre> <p>Gets the acceleration data from the inertial measurement unit.</p> <p>Returns:</p> <ul> <li> <code>Acceleration</code>           \u2013            <p>An Acceleration object containing the x, y, and z acceleration values in m/s\u00b2.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>SensorReadingValueError</code>             \u2013            <p>If the reading returns an invalid value.</p> </li> <li> <code>SensorReadingTimeoutError</code>             \u2013            <p>If the reading times out.</p> </li> <li> <code>SensorReadingUnknownError</code>             \u2013            <p>If an unknown error occurs while reading the light sensor.</p> </li> </ul>"},{"location":"api/#pysquared.protos.imu.IMUProto.get_angular_velocity","title":"get_angular_velocity","text":"<pre><code>get_angular_velocity() -&gt; AngularVelocity\n</code></pre> <p>Gets the angular velocity from the inertial measurement unit.</p> <p>Returns:</p> <ul> <li> <code>AngularVelocity</code>           \u2013            <p>An AngularVelocity object containing the x, y, and z angular velocity in radians per second.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>SensorReadingValueError</code>             \u2013            <p>If the reading returns an invalid value.</p> </li> <li> <code>SensorReadingTimeoutError</code>             \u2013            <p>If the reading times out.</p> </li> <li> <code>SensorReadingUnknownError</code>             \u2013            <p>If an unknown error occurs while reading the light sensor.</p> </li> </ul>"},{"location":"api/#pysquared.protos.light_sensor","title":"light_sensor","text":"<p>This protocol specifies the interface that any light sensor implementation must adhere to, ensuring consistent behavior across different light sensor hardware.</p> <p>Classes:</p> <ul> <li> <code>LightSensorProto</code>           \u2013            <p>Protocol defining the interface for a light sensor.</p> </li> </ul>"},{"location":"api/#pysquared.protos.light_sensor.LightSensorProto","title":"LightSensorProto","text":"<p>Protocol defining the interface for a light sensor.</p> <p>Methods:</p> <ul> <li> <code>get_light</code>             \u2013              <p>Gets the light reading of the sensor.</p> </li> <li> <code>get_lux</code>             \u2013              <p>Gets the lux reading of the sensor.</p> </li> </ul>"},{"location":"api/#pysquared.protos.light_sensor.LightSensorProto.get_light","title":"get_light","text":"<pre><code>get_light() -&gt; Light\n</code></pre> <p>Gets the light reading of the sensor.</p> <p>Returns:</p> <ul> <li> <code>Light</code>           \u2013            <p>A Light object containing a non-unit-specific light level reading.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>SensorReadingValueError</code>             \u2013            <p>If the reading returns an invalid value.</p> </li> <li> <code>SensorReadingTimeoutError</code>             \u2013            <p>If the reading times out.</p> </li> <li> <code>SensorReadingUnknownError</code>             \u2013            <p>If an unknown error occurs while reading the light sensor.</p> </li> </ul>"},{"location":"api/#pysquared.protos.light_sensor.LightSensorProto.get_lux","title":"get_lux","text":"<pre><code>get_lux() -&gt; Lux\n</code></pre> <p>Gets the lux reading of the sensor.</p> <p>Returns:</p> <ul> <li> <code>Lux</code>           \u2013            <p>A Lux object containing the light level in SI lux.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>SensorReadingValueError</code>             \u2013            <p>If the reading returns an invalid value.</p> </li> <li> <code>SensorReadingTimeoutError</code>             \u2013            <p>If the reading times out.</p> </li> <li> <code>SensorReadingUnknownError</code>             \u2013            <p>If an unknown error occurs while reading the light sensor.</p> </li> </ul>"},{"location":"api/#pysquared.protos.loadswitch","title":"loadswitch","text":"<p>Load switch manager protocol for generic components.</p> <p>Classes:</p> <ul> <li> <code>LoadSwitchManagerProto</code>           \u2013            <p>Protocol for load switch management in generic systems.</p> </li> </ul>"},{"location":"api/#pysquared.protos.loadswitch.LoadSwitchManagerProto","title":"LoadSwitchManagerProto","text":"<p>Protocol for load switch management in generic systems. This protocol defines the interface for managing load switches that control power to components. Load switches can be enabled, disabled, and reset with momentary power cycling.</p> <p>Methods:</p> <ul> <li> <code>disable_load</code>             \u2013              <p>Disable the load switch to cut power to the component.</p> </li> <li> <code>enable_load</code>             \u2013              <p>Enable the load switch to provide power to the component.</p> </li> <li> <code>reset_load</code>             \u2013              <p>Reset the load switch by momentarily disabling then re-enabling it.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>is_enabled</code>               (<code>bool</code>)           \u2013            <p>Check if the load switch is currently enabled.</p> </li> </ul>"},{"location":"api/#pysquared.protos.loadswitch.LoadSwitchManagerProto.is_enabled","title":"is_enabled  <code>property</code>","text":"<pre><code>is_enabled: bool\n</code></pre> <p>Check if the load switch is currently enabled. :raises RuntimeError: If the load switch state cannot be read due to hardware issues :return: True if the load switch is enabled, False otherwise</p>"},{"location":"api/#pysquared.protos.loadswitch.LoadSwitchManagerProto.disable_load","title":"disable_load","text":"<pre><code>disable_load() -&gt; None\n</code></pre> <p>Disable the load switch to cut power to the component. :raises RuntimeError: If the load switch cannot be disabled due to hardware issues</p>"},{"location":"api/#pysquared.protos.loadswitch.LoadSwitchManagerProto.enable_load","title":"enable_load","text":"<pre><code>enable_load() -&gt; None\n</code></pre> <p>Enable the load switch to provide power to the component. :raises RuntimeError: If the load switch cannot be enabled due to hardware issues</p>"},{"location":"api/#pysquared.protos.loadswitch.LoadSwitchManagerProto.reset_load","title":"reset_load","text":"<pre><code>reset_load() -&gt; None\n</code></pre> <p>Reset the load switch by momentarily disabling then re-enabling it. This method performs a momentary power cycle (0.1s) to reset the load switch and any connected components. Errors from underlying drivers are reraised. :raises RuntimeError: If the load switch cannot be reset due to hardware issues</p>"},{"location":"api/#pysquared.protos.magnetometer","title":"magnetometer","text":"<p>This protocol specifies the interface that any magnetometer implementation must adhere to, ensuring consistent behavior across different magnetometer hardware.</p> <p>Classes:</p> <ul> <li> <code>MagnetometerProto</code>           \u2013            <p>Protocol defining the interface for a Magnetometer.</p> </li> </ul>"},{"location":"api/#pysquared.protos.magnetometer.MagnetometerProto","title":"MagnetometerProto","text":"<p>Protocol defining the interface for a Magnetometer.</p> <p>Methods:</p> <ul> <li> <code>get_magnetic_field</code>             \u2013              <p>Gets the magnetic field vector from the magnetometer.</p> </li> </ul>"},{"location":"api/#pysquared.protos.magnetometer.MagnetometerProto.get_magnetic_field","title":"get_magnetic_field","text":"<pre><code>get_magnetic_field() -&gt; Magnetic\n</code></pre> <p>Gets the magnetic field vector from the magnetometer.</p> <p>Returns:</p> <ul> <li> <code>Magnetic</code>           \u2013            <p>A Magnetic object containing the x, y, and z magnetic field values in micro-Tesla (uT)</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>SensorReadingTimeoutError</code>             \u2013            <p>If the reading times out.</p> </li> <li> <code>SensorReadingUnknownError</code>             \u2013            <p>If an unknown error occurs while reading the magnetometer.</p> </li> </ul>"},{"location":"api/#pysquared.protos.power_monitor","title":"power_monitor","text":"<p>This protocol specifies the interface that any power monitor implementation must adhere to, ensuring consistent behavior across different power monitor hardware.</p> <p>Classes:</p> <ul> <li> <code>PowerMonitorProto</code>           \u2013            <p>Protocol defining the interface for a Power Monitor.</p> </li> </ul>"},{"location":"api/#pysquared.protos.power_monitor.PowerMonitorProto","title":"PowerMonitorProto","text":"<p>Protocol defining the interface for a Power Monitor.</p> <p>Methods:</p> <ul> <li> <code>get_bus_voltage</code>             \u2013              <p>Gets the bus voltage from the power monitor.</p> </li> <li> <code>get_current</code>             \u2013              <p>Gets the current from the power monitor.</p> </li> <li> <code>get_shunt_voltage</code>             \u2013              <p>Gets the shunt voltage from the power monitor.</p> </li> </ul>"},{"location":"api/#pysquared.protos.power_monitor.PowerMonitorProto.get_bus_voltage","title":"get_bus_voltage","text":"<pre><code>get_bus_voltage() -&gt; Voltage\n</code></pre> <p>Gets the bus voltage from the power monitor.</p> <p>Returns:</p> <ul> <li> <code>Voltage</code>           \u2013            <p>A Voltage object containing the bus voltage in volts.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>SensorReadingValueError</code>             \u2013            <p>If the reading returns an invalid value.</p> </li> <li> <code>SensorReadingTimeoutError</code>             \u2013            <p>If the reading times out.</p> </li> <li> <code>SensorReadingUnknownError</code>             \u2013            <p>If an unknown error occurs while reading the light sensor.</p> </li> </ul>"},{"location":"api/#pysquared.protos.power_monitor.PowerMonitorProto.get_current","title":"get_current","text":"<pre><code>get_current() -&gt; Current\n</code></pre> <p>Gets the current from the power monitor.</p> <p>Returns:</p> <ul> <li> <code>Current</code>           \u2013            <p>A Current object containing the current in milliamps (mA)</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>SensorReadingValueError</code>             \u2013            <p>If the reading returns an invalid value.</p> </li> <li> <code>SensorReadingTimeoutError</code>             \u2013            <p>If the reading times out.</p> </li> <li> <code>SensorReadingUnknownError</code>             \u2013            <p>If an unknown error occurs while reading the light sensor.</p> </li> </ul>"},{"location":"api/#pysquared.protos.power_monitor.PowerMonitorProto.get_shunt_voltage","title":"get_shunt_voltage","text":"<pre><code>get_shunt_voltage() -&gt; Voltage\n</code></pre> <p>Gets the shunt voltage from the power monitor.</p> <p>Returns:</p> <ul> <li> <code>Voltage</code>           \u2013            <p>A Voltage object containing the shunt voltage in volts.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>SensorReadingValueError</code>             \u2013            <p>If the reading returns an invalid value.</p> </li> <li> <code>SensorReadingTimeoutError</code>             \u2013            <p>If the reading times out.</p> </li> <li> <code>SensorReadingUnknownError</code>             \u2013            <p>If an unknown error occurs while reading the light sensor.</p> </li> </ul>"},{"location":"api/#pysquared.protos.radio","title":"radio","text":"<p>This protocol specifies the interface that any radio implementation must adhere to, ensuring consistent behavior across different radio hardware.</p> <p>Classes:</p> <ul> <li> <code>RadioProto</code>           \u2013            <p>Protocol defining the interface for a radio.</p> </li> </ul>"},{"location":"api/#pysquared.protos.radio.RadioProto","title":"RadioProto","text":"<p>Protocol defining the interface for a radio.</p> <p>Methods:</p> <ul> <li> <code>get_max_packet_size</code>             \u2013              <p>Gets the maximum packet size supported by the radio.</p> </li> <li> <code>get_modulation</code>             \u2013              <p>Gets the currently configured or active radio modulation mode.</p> </li> <li> <code>get_rssi</code>             \u2013              <p>Gets the RSSI of the last received packet.</p> </li> <li> <code>modify_config</code>             \u2013              <p>Modifies a specific radio configuration parameter.</p> </li> <li> <code>receive</code>             \u2013              <p>Receives data from the radio.</p> </li> <li> <code>send</code>             \u2013              <p>Sends data over the radio.</p> </li> <li> <code>set_modulation</code>             \u2013              <p>Requests a change in the radio modulation mode.</p> </li> </ul>"},{"location":"api/#pysquared.protos.radio.RadioProto.get_max_packet_size","title":"get_max_packet_size","text":"<pre><code>get_max_packet_size() -&gt; int\n</code></pre> <p>Gets the maximum packet size supported by the radio.</p> <p>Returns:</p> <ul> <li> <code>int</code>           \u2013            <p>The maximum packet size in bytes.</p> </li> </ul>"},{"location":"api/#pysquared.protos.radio.RadioProto.get_modulation","title":"get_modulation","text":"<pre><code>get_modulation() -&gt; Type[RadioModulation]\n</code></pre> <p>Gets the currently configured or active radio modulation mode.</p> <p>Returns:</p> <ul> <li> <code>Type[RadioModulation]</code>           \u2013            <p>The current modulation mode.</p> </li> </ul>"},{"location":"api/#pysquared.protos.radio.RadioProto.get_rssi","title":"get_rssi","text":"<pre><code>get_rssi() -&gt; int\n</code></pre> <p>Gets the RSSI of the last received packet.</p> <p>Returns:</p> <ul> <li> <code>int</code>           \u2013            <p>The RSSI value in dBm.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>NotImplementedError</code>             \u2013            <p>If not implemented by subclass.</p> </li> </ul>"},{"location":"api/#pysquared.protos.radio.RadioProto.modify_config","title":"modify_config","text":"<pre><code>modify_config(key: str, value) -&gt; None\n</code></pre> <p>Modifies a specific radio configuration parameter.</p> <p>Parameters:</p> <p>Raises:</p> <ul> <li> <code>NotImplementedError</code>             \u2013            <p>If not implemented by subclass.</p> </li> </ul>"},{"location":"api/#pysquared.protos.radio.RadioProto.modify_config(key)","title":"<code>key</code>","text":"(<code>str</code>)           \u2013            <p>The configuration parameter key to modify.</p>"},{"location":"api/#pysquared.protos.radio.RadioProto.modify_config(value)","title":"<code>value</code>","text":"\u2013            <p>The new value to set for the parameter.</p>"},{"location":"api/#pysquared.protos.radio.RadioProto.receive","title":"receive","text":"<pre><code>receive(timeout: Optional[int] = None) -&gt; Optional[bytes]\n</code></pre> <p>Receives data from the radio.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Optional[bytes]</code>           \u2013            <p>The received data as bytes, or None if no data was received.</p> </li> </ul>"},{"location":"api/#pysquared.protos.radio.RadioProto.receive(timeout)","title":"<code>timeout</code>","text":"(<code>Optional[int]</code>, default:                   <code>None</code> )           \u2013            <p>Optional receive timeout in seconds. If None, use the default timeout.</p>"},{"location":"api/#pysquared.protos.radio.RadioProto.send","title":"send","text":"<pre><code>send(data: bytes) -&gt; bool\n</code></pre> <p>Sends data over the radio.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>True if the send was successful, False otherwise.</p> </li> </ul>"},{"location":"api/#pysquared.protos.radio.RadioProto.send(data)","title":"<code>data</code>","text":"(<code>bytes</code>)           \u2013            <p>The data to send.</p>"},{"location":"api/#pysquared.protos.radio.RadioProto.set_modulation","title":"set_modulation","text":"<pre><code>set_modulation(modulation: Type[RadioModulation]) -&gt; None\n</code></pre> <p>Requests a change in the radio modulation mode.</p> <p>This change might take effect immediately or after a reset, depending on implementation.</p> <p>Parameters:</p>"},{"location":"api/#pysquared.protos.radio.RadioProto.set_modulation(modulation)","title":"<code>modulation</code>","text":"(<code>Type[RadioModulation]</code>)           \u2013            <p>The desired modulation mode.</p>"},{"location":"api/#pysquared.protos.reading","title":"reading","text":"<p>This protocol specifies the interface that any sensor reading protocol implementation must adhere to, ensuring consistent behavior across different types of sensor readings.</p> <p>Classes:</p> <ul> <li> <code>ReadingProto</code>           \u2013            <p>Protocol defining the interface for a sensor reading.</p> </li> </ul>"},{"location":"api/#pysquared.protos.reading.ReadingProto","title":"ReadingProto","text":"<p>Protocol defining the interface for a sensor reading.</p> <p>Attributes:</p> <ul> <li> <code>timestamp</code>               (<code>float</code>)           \u2013            <p>Gets the timestamp of the reading.</p> </li> <li> <code>value</code>               (<code>Tuple[float, float, float] | float</code>)           \u2013            <p>Gets the value of the sensor reading.</p> </li> </ul>"},{"location":"api/#pysquared.protos.reading.ReadingProto.timestamp","title":"timestamp  <code>property</code>","text":"<pre><code>timestamp: float\n</code></pre> <p>Gets the timestamp of the reading.</p> <p>Returns:</p> <ul> <li> <code>float</code>           \u2013            <p>The timestamp of the reading in seconds since the epoch.</p> </li> </ul>"},{"location":"api/#pysquared.protos.reading.ReadingProto.value","title":"value  <code>property</code>","text":"<pre><code>value: Tuple[float, float, float] | float\n</code></pre> <p>Gets the value of the sensor reading.</p> <p>Returns:</p> <ul> <li> <code>Tuple[float, float, float] | float</code>           \u2013            <p>The reading value, which may be a float or a tuple of floats, depending on the implementation.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>SensorReadingValueError</code>             \u2013            <p>If the sensor reading returns an invalid value.</p> </li> <li> <code>SensorReadingTimeoutError</code>             \u2013            <p>If the sensor reading times out.</p> </li> <li> <code>SensorReadingUnknownError</code>             \u2013            <p>If an unknown error occurs while reading the sensor.</p> </li> </ul>"},{"location":"api/#pysquared.protos.rtc","title":"rtc","text":"<p>This protocol specifies the interface that any Real-Time Clock (RTC) implementation must adhere to, ensuring consistent behavior across different RTC hardware.</p> <p>Classes:</p> <ul> <li> <code>RTCProto</code>           \u2013            <p>Protocol defining the interface for a Real Time Clock (RTC).</p> </li> </ul>"},{"location":"api/#pysquared.protos.rtc.RTCProto","title":"RTCProto","text":"<p>Protocol defining the interface for a Real Time Clock (RTC).</p> <p>Methods:</p> <ul> <li> <code>set_time</code>             \u2013              <p>Sets the time on the real-time clock.</p> </li> </ul>"},{"location":"api/#pysquared.protos.rtc.RTCProto.set_time","title":"set_time","text":"<pre><code>set_time(year: int, month: int, date: int, hour: int, minute: int, second: int, weekday: int) -&gt; None\n</code></pre> <p>Sets the time on the real-time clock.</p> <p>Parameters:</p> <p>Raises:</p> <ul> <li> <code>Exception</code>             \u2013            <p>If there is an error setting the values.</p> </li> </ul>"},{"location":"api/#pysquared.protos.rtc.RTCProto.set_time(year)","title":"<code>year</code>","text":"(<code>int</code>)           \u2013            <p>The year value (0-9999).</p>"},{"location":"api/#pysquared.protos.rtc.RTCProto.set_time(month)","title":"<code>month</code>","text":"(<code>int</code>)           \u2013            <p>The month value (1-12).</p>"},{"location":"api/#pysquared.protos.rtc.RTCProto.set_time(date)","title":"<code>date</code>","text":"(<code>int</code>)           \u2013            <p>The date value (1-31).</p>"},{"location":"api/#pysquared.protos.rtc.RTCProto.set_time(hour)","title":"<code>hour</code>","text":"(<code>int</code>)           \u2013            <p>The hour value (0-23).</p>"},{"location":"api/#pysquared.protos.rtc.RTCProto.set_time(minute)","title":"<code>minute</code>","text":"(<code>int</code>)           \u2013            <p>The minute value (0-59).</p>"},{"location":"api/#pysquared.protos.rtc.RTCProto.set_time(second)","title":"<code>second</code>","text":"(<code>int</code>)           \u2013            <p>The second value (0-59).</p>"},{"location":"api/#pysquared.protos.rtc.RTCProto.set_time(weekday)","title":"<code>weekday</code>","text":"(<code>int</code>)           \u2013            <p>The nth day of the week (0-6), where 0 represents Sunday and 6 represents Saturday.</p>"},{"location":"api/#pysquared.protos.temperature_sensor","title":"temperature_sensor","text":"<p>This protocol specifies the interface that any temperature sensor implementation must adhere to, ensuring consistent behavior across different temperature sensor hardware.</p> <p>Classes:</p> <ul> <li> <code>TemperatureSensorProto</code>           \u2013            <p>Protocol defining the interface for a temperature sensor.</p> </li> </ul>"},{"location":"api/#pysquared.protos.temperature_sensor.TemperatureSensorProto","title":"TemperatureSensorProto","text":"<p>Protocol defining the interface for a temperature sensor.</p> <p>Methods:</p> <ul> <li> <code>get_temperature</code>             \u2013              <p>Gets the temperature reading of the sensor.</p> </li> </ul>"},{"location":"api/#pysquared.protos.temperature_sensor.TemperatureSensorProto.get_temperature","title":"get_temperature","text":"<pre><code>get_temperature() -&gt; Temperature\n</code></pre> <p>Gets the temperature reading of the sensor.</p> <p>Returns:</p> <ul> <li> <code>Temperature</code>           \u2013            <p>A Temperature object containing the temperature in degrees Celsius.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>SensorReadingValueError</code>             \u2013            <p>If the reading returns an invalid value.</p> </li> <li> <code>SensorReadingTimeoutError</code>             \u2013            <p>If the reading times out.</p> </li> <li> <code>SensorReadingUnknownError</code>             \u2013            <p>If an unknown error occurs while reading the temperature</p> </li> </ul>"},{"location":"api/#pysquared.rtc","title":"rtc","text":"<p>This module provides Real-Time Clock (RTC) management functionality for the PySquared satellite.</p> <p>Modules:</p> <ul> <li> <code>manager</code>           \u2013            <p>This module provides the managers for various Real-Time Clock (RTC) implementations</p> </li> </ul>"},{"location":"api/#pysquared.rtc.manager","title":"manager","text":"<p>This module provides the managers for various Real-Time Clock (RTC) implementations</p> <p>Modules:</p> <ul> <li> <code>microcontroller</code>           \u2013            <p>This module provides a manager for the Microcontroller's Real-Time Clock (RTC).</p> </li> <li> <code>rv3028</code>           \u2013            <p>This module provides a manager for the RV3028 Real-Time Clock (RTC).</p> </li> </ul>"},{"location":"api/#pysquared.rtc.manager.microcontroller","title":"microcontroller","text":"<p>This module provides a manager for the Microcontroller's Real-Time Clock (RTC).</p> <p>This module defines the <code>MicrocontrollerManager</code> class, which provides an interface for interacting with the microcontroller's built-in RTC. It allows for setting the current time.</p> <p>Usage: <pre><code>rtc_manager = MicrocontrollerManager()\nrtc_manager.set_time(2024, 7, 8, 10, 30, 0, 1) # Set to July 8, 2024, 10:30:00 AM, Monday\n</code></pre></p> <p>Classes:</p> <ul> <li> <code>MicrocontrollerManager</code>           \u2013            <p>Manages the Microcontroller's Real Time Clock (RTC).</p> </li> </ul>"},{"location":"api/#pysquared.rtc.manager.microcontroller.MicrocontrollerManager","title":"MicrocontrollerManager","text":"<pre><code>MicrocontrollerManager()\n</code></pre> <p>               Bases: <code>RTCProto</code></p> <p>Manages the Microcontroller's Real Time Clock (RTC).</p> <p>This method is required on every boot to ensure the RTC is ready for use.</p> <p>Methods:</p> <ul> <li> <code>set_time</code>             \u2013              <p>Updates the Microcontroller's Real Time Clock (RTC).</p> </li> </ul>"},{"location":"api/#pysquared.rtc.manager.microcontroller.MicrocontrollerManager.set_time","title":"set_time","text":"<pre><code>set_time(year: int, month: int, date: int, hour: int, minute: int, second: int, weekday: int) -&gt; None\n</code></pre> <p>Updates the Microcontroller's Real Time Clock (RTC).</p> <p>Parameters:</p> <ul> <li> <code>year</code>               (<code>int</code>)           \u2013            <p>The year value (0-9999).</p> </li> <li> <code>month</code>               (<code>int</code>)           \u2013            <p>The month value (1-12).</p> </li> <li> <code>date</code>               (<code>int</code>)           \u2013            <p>The date value (1-31).</p> </li> <li> <code>hour</code>               (<code>int</code>)           \u2013            <p>The hour value (0-23).</p> </li> <li> <code>minute</code>               (<code>int</code>)           \u2013            <p>The minute value (0-59).</p> </li> <li> <code>second</code>               (<code>int</code>)           \u2013            <p>The second value (0-59).</p> </li> <li> <code>weekday</code>               (<code>int</code>)           \u2013            <p>The nth day of the week (0-6), where 0 represents Sunday and 6 represents Saturday.</p> </li> </ul>"},{"location":"api/#pysquared.rtc.manager.rv3028","title":"rv3028","text":"<p>This module provides a manager for the RV3028 Real-Time Clock (RTC).</p> <p>This module defines the <code>RV3028Manager</code> class, which provides a high-level interface for interacting with the RV3028 RTC. It handles the initialization of the sensor and provides methods for setting the current time.</p> <p>Usage: <pre><code>logger = Logger()\ni2c = busio.I2C(board.SCL, board.SDA)\nrtc_manager = RV3028Manager(logger, i2c)\nrtc_manager.set_time(2024, 7, 8, 10, 30, 0, 1) # Set to July 8, 2024, 10:30:00 AM, Monday\n</code></pre></p> <p>Classes:</p> <ul> <li> <code>RV3028Manager</code>           \u2013            <p>Manages the RV3028 RTC.</p> </li> </ul>"},{"location":"api/#pysquared.rtc.manager.rv3028.RV3028Manager","title":"RV3028Manager","text":"<pre><code>RV3028Manager(logger: Logger, i2c: I2C)\n</code></pre> <p>               Bases: <code>RTCProto</code></p> <p>Manages the RV3028 RTC.</p> <p>Parameters:</p> <p>Raises:</p> <ul> <li> <code>HardwareInitializationError</code>             \u2013            <p>If the RTC fails to initialize.</p> </li> </ul> <p>Methods:</p> <ul> <li> <code>set_time</code>             \u2013              <p>Sets the time on the real-time clock.</p> </li> </ul>"},{"location":"api/#pysquared.rtc.manager.rv3028.RV3028Manager(logger)","title":"<code>logger</code>","text":"(<code>Logger</code>)           \u2013            <p>The logger to use.</p>"},{"location":"api/#pysquared.rtc.manager.rv3028.RV3028Manager(i2c)","title":"<code>i2c</code>","text":"(<code>I2C</code>)           \u2013            <p>The I2C bus connected to the chip.</p>"},{"location":"api/#pysquared.rtc.manager.rv3028.RV3028Manager.set_time","title":"set_time","text":"<pre><code>set_time(year: int, month: int, date: int, hour: int, minute: int, second: int, weekday: int) -&gt; None\n</code></pre> <p>Sets the time on the real-time clock.</p> <p>Parameters:</p> <ul> <li> <code>year</code>               (<code>int</code>)           \u2013            <p>The year value (0-9999).</p> </li> <li> <code>month</code>               (<code>int</code>)           \u2013            <p>The month value (1-12).</p> </li> <li> <code>date</code>               (<code>int</code>)           \u2013            <p>The date value (1-31).</p> </li> <li> <code>hour</code>               (<code>int</code>)           \u2013            <p>The hour value (0-23).</p> </li> <li> <code>minute</code>               (<code>int</code>)           \u2013            <p>The minute value (0-59).</p> </li> <li> <code>second</code>               (<code>int</code>)           \u2013            <p>The second value (0-59).</p> </li> <li> <code>weekday</code>               (<code>int</code>)           \u2013            <p>The nth day of the week (0-6), where 0 represents Sunday and 6 represents Saturday.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>Exception</code>             \u2013            <p>If there is an error setting the values.</p> </li> </ul>"},{"location":"api/#pysquared.sensor_reading","title":"sensor_reading","text":"<p>Module for sensor reading definitions.</p> <p>Modules:</p> <ul> <li> <code>acceleration</code>           \u2013            <p>Acceleration sensor reading.</p> </li> <li> <code>angular_velocity</code>           \u2013            <p>AngularVelocity sensor reading.</p> </li> <li> <code>avg</code>           \u2013            <p>File with helper for averaging sensor readings.</p> </li> <li> <code>base</code>           \u2013            <p>A sensor reading.</p> </li> <li> <code>current</code>           \u2013            <p>Current sensor reading.</p> </li> <li> <code>error</code>           \u2013            <p>This file contains custom error classes for handling sensor reading errors.</p> </li> <li> <code>light</code>           \u2013            <p>Light sensor reading.</p> </li> <li> <code>lux</code>           \u2013            <p>Lux sensor reading.</p> </li> <li> <code>magnetic</code>           \u2013            <p>Magnetic sensor reading.</p> </li> <li> <code>temperature</code>           \u2013            <p>Temperature sensor reading.</p> </li> <li> <code>voltage</code>           \u2013            <p>Voltage sensor reading.</p> </li> </ul>"},{"location":"api/#pysquared.sensor_reading.acceleration","title":"acceleration","text":"<p>Acceleration sensor reading.</p> <p>Classes:</p> <ul> <li> <code>Acceleration</code>           \u2013            <p>Acceleration sensor reading in meter per second\u00b2.</p> </li> </ul>"},{"location":"api/#pysquared.sensor_reading.acceleration.Acceleration","title":"Acceleration","text":"<pre><code>Acceleration(x: float, y: float, z: float)\n</code></pre> <p>               Bases: <code>Reading</code></p> <p>Acceleration sensor reading in meter per second\u00b2.</p> <p>Parameters:</p> <p>Methods:</p> <ul> <li> <code>to_dict</code>             \u2013              <p>Convert reading to dictionary for JSON serialization.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>timestamp</code>           \u2013            <p>Get the timestamp of the reading.</p> </li> <li> <code>value</code>               (<code>Tuple[float, float, float]</code>)           \u2013            <p>Acceleration in x, y, z meter per second\u00b2.</p> </li> </ul>"},{"location":"api/#pysquared.sensor_reading.acceleration.Acceleration(x)","title":"<code>x</code>","text":"(<code>float</code>)           \u2013            <p>The x acceleration in meter per second\u00b2</p>"},{"location":"api/#pysquared.sensor_reading.acceleration.Acceleration(y)","title":"<code>y</code>","text":"(<code>float</code>)           \u2013            <p>The y acceleration in meter per second\u00b2</p>"},{"location":"api/#pysquared.sensor_reading.acceleration.Acceleration(z)","title":"<code>z</code>","text":"(<code>float</code>)           \u2013            <p>The z acceleration in meter per second\u00b2</p>"},{"location":"api/#pysquared.sensor_reading.acceleration.Acceleration.timestamp","title":"timestamp  <code>property</code>","text":"<pre><code>timestamp\n</code></pre> <p>Get the timestamp of the reading.</p>"},{"location":"api/#pysquared.sensor_reading.acceleration.Acceleration.value","title":"value  <code>property</code>","text":"<pre><code>value: Tuple[float, float, float]\n</code></pre> <p>Acceleration in x, y, z meter per second\u00b2.</p> <p>Returns:</p> <ul> <li> <code>Tuple[float, float, float]</code>           \u2013            <p>A tuple containing the x, y, and z components of the acceleration.</p> </li> </ul>"},{"location":"api/#pysquared.sensor_reading.acceleration.Acceleration.to_dict","title":"to_dict","text":"<pre><code>to_dict() -&gt; dict\n</code></pre> <p>Convert reading to dictionary for JSON serialization.</p>"},{"location":"api/#pysquared.sensor_reading.angular_velocity","title":"angular_velocity","text":"<p>AngularVelocity sensor reading.</p> <p>Classes:</p> <ul> <li> <code>AngularVelocity</code>           \u2013            <p>AngularVelocity sensor reading in radians per second.</p> </li> </ul>"},{"location":"api/#pysquared.sensor_reading.angular_velocity.AngularVelocity","title":"AngularVelocity","text":"<pre><code>AngularVelocity(x: float, y: float, z: float)\n</code></pre> <p>               Bases: <code>Reading</code></p> <p>AngularVelocity sensor reading in radians per second.</p> <p>Parameters:</p> <p>Methods:</p> <ul> <li> <code>to_dict</code>             \u2013              <p>Convert reading to dictionary for JSON serialization.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>timestamp</code>           \u2013            <p>Get the timestamp of the reading.</p> </li> <li> <code>value</code>               (<code>Tuple[float, float, float]</code>)           \u2013            <p>Angular velocity in x, y, z radians per second</p> </li> </ul>"},{"location":"api/#pysquared.sensor_reading.angular_velocity.AngularVelocity(x)","title":"<code>x</code>","text":"(<code>float</code>)           \u2013            <p>The x angular velocity in radians per second</p>"},{"location":"api/#pysquared.sensor_reading.angular_velocity.AngularVelocity(y)","title":"<code>y</code>","text":"(<code>float</code>)           \u2013            <p>The y angular velocity in radians per second</p>"},{"location":"api/#pysquared.sensor_reading.angular_velocity.AngularVelocity(z)","title":"<code>z</code>","text":"(<code>float</code>)           \u2013            <p>The z angular velocity in radians per second</p>"},{"location":"api/#pysquared.sensor_reading.angular_velocity.AngularVelocity.timestamp","title":"timestamp  <code>property</code>","text":"<pre><code>timestamp\n</code></pre> <p>Get the timestamp of the reading.</p>"},{"location":"api/#pysquared.sensor_reading.angular_velocity.AngularVelocity.value","title":"value  <code>property</code>","text":"<pre><code>value: Tuple[float, float, float]\n</code></pre> <p>Angular velocity in x, y, z radians per second</p> <p>Returns:</p> <ul> <li> <code>Tuple[float, float, float]</code>           \u2013            <p>A tuple containing the x, y, and z components of the angular velocity.</p> </li> </ul>"},{"location":"api/#pysquared.sensor_reading.angular_velocity.AngularVelocity.to_dict","title":"to_dict","text":"<pre><code>to_dict() -&gt; dict\n</code></pre> <p>Convert reading to dictionary for JSON serialization.</p>"},{"location":"api/#pysquared.sensor_reading.avg","title":"avg","text":"<p>File with helper for averaging sensor readings.</p> <p>Functions:</p> <ul> <li> <code>avg_readings</code>             \u2013              <p>Gets the average of the readings from a function.</p> </li> </ul>"},{"location":"api/#pysquared.sensor_reading.avg.avg_readings","title":"avg_readings","text":"<pre><code>avg_readings(func: Callable[..., Current | Voltage], num_readings: int = 50) -&gt; float\n</code></pre> <p>Gets the average of the readings from a function.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>float</code>           \u2013            <p>The average of the readings, or None if the readings could not be taken.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>RuntimeError</code>             \u2013            <p>If there is an error retrieving the reading from the function.</p> </li> </ul>"},{"location":"api/#pysquared.sensor_reading.avg.avg_readings(func)","title":"<code>func</code>","text":"(<code>Callable[..., Current | Voltage]</code>)           \u2013            <p>The function to call.</p>"},{"location":"api/#pysquared.sensor_reading.avg.avg_readings(num_readings)","title":"<code>num_readings</code>","text":"(<code>int</code>, default:                   <code>50</code> )           \u2013            <p>The number of readings to take.</p>"},{"location":"api/#pysquared.sensor_reading.base","title":"base","text":"<p>A sensor reading.</p> <p>Classes:</p> <ul> <li> <code>Reading</code>           \u2013            <p>A sensor reading.</p> </li> </ul>"},{"location":"api/#pysquared.sensor_reading.base.Reading","title":"Reading","text":"<pre><code>Reading()\n</code></pre> <p>               Bases: <code>ReadingProto</code></p> <p>A sensor reading.</p> <p>Methods:</p> <ul> <li> <code>to_dict</code>             \u2013              <p>Convert reading to dictionary for JSON serialization.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>timestamp</code>           \u2013            <p>Get the timestamp of the reading.</p> </li> <li> <code>value</code>               (<code>Tuple[float, float, float] | float</code>)           \u2013            <p>Get the value of the reading.</p> </li> </ul>"},{"location":"api/#pysquared.sensor_reading.base.Reading.timestamp","title":"timestamp  <code>property</code>","text":"<pre><code>timestamp\n</code></pre> <p>Get the timestamp of the reading.</p>"},{"location":"api/#pysquared.sensor_reading.base.Reading.value","title":"value  <code>property</code>","text":"<pre><code>value: Tuple[float, float, float] | float\n</code></pre> <p>Get the value of the reading.</p> <p>This method should be overridden by subclasses to return the specific sensor reading value.</p>"},{"location":"api/#pysquared.sensor_reading.base.Reading.to_dict","title":"to_dict","text":"<pre><code>to_dict() -&gt; dict\n</code></pre> <p>Convert reading to dictionary for JSON serialization.</p>"},{"location":"api/#pysquared.sensor_reading.current","title":"current","text":"<p>Current sensor reading.</p> <p>Classes:</p> <ul> <li> <code>Current</code>           \u2013            <p>Current sensor reading in milliamps (mA).</p> </li> </ul>"},{"location":"api/#pysquared.sensor_reading.current.Current","title":"Current","text":"<pre><code>Current(value: float)\n</code></pre> <p>               Bases: <code>Reading</code></p> <p>Current sensor reading in milliamps (mA).</p> <p>Parameters:</p> <p>Methods:</p> <ul> <li> <code>to_dict</code>             \u2013              <p>Convert reading to dictionary for JSON serialization.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>timestamp</code>           \u2013            <p>Get the timestamp of the reading.</p> </li> <li> <code>value</code>               (<code>float</code>)           \u2013            <p>Get the current value in milliamps (mA).</p> </li> </ul>"},{"location":"api/#pysquared.sensor_reading.current.Current(value)","title":"<code>value</code>","text":"(<code>float</code>)           \u2013            <p>The current in milliamps (mA)</p>"},{"location":"api/#pysquared.sensor_reading.current.Current.timestamp","title":"timestamp  <code>property</code>","text":"<pre><code>timestamp\n</code></pre> <p>Get the timestamp of the reading.</p>"},{"location":"api/#pysquared.sensor_reading.current.Current.value","title":"value  <code>property</code>","text":"<pre><code>value: float\n</code></pre> <p>Get the current value in milliamps (mA).</p> <p>Returns:</p> <ul> <li> <code>float</code>           \u2013            <p>The current in milliamps (mA).</p> </li> </ul>"},{"location":"api/#pysquared.sensor_reading.current.Current.to_dict","title":"to_dict","text":"<pre><code>to_dict() -&gt; dict\n</code></pre> <p>Convert reading to dictionary for JSON serialization.</p>"},{"location":"api/#pysquared.sensor_reading.error","title":"error","text":"<p>This file contains custom error classes for handling sensor reading errors.</p> <p>Classes:</p> <ul> <li> <code>SensorReadingError</code>           \u2013            <p>Base class for all sensor reading errors.</p> </li> <li> <code>SensorReadingTimeoutError</code>           \u2013            <p>Raised when a sensor reading operation times out.</p> </li> <li> <code>SensorReadingUnknownError</code>           \u2013            <p>Raised when an unknown error occurs during sensor reading.</p> </li> <li> <code>SensorReadingValueError</code>           \u2013            <p>Raised when a sensor reading returns an invalid value.</p> </li> </ul>"},{"location":"api/#pysquared.sensor_reading.error.SensorReadingError","title":"SensorReadingError","text":"<p>               Bases: <code>Exception</code></p> <p>Base class for all sensor reading errors.</p>"},{"location":"api/#pysquared.sensor_reading.error.SensorReadingTimeoutError","title":"SensorReadingTimeoutError","text":"<pre><code>SensorReadingTimeoutError(message: str = 'Sensor reading operation timed out.')\n</code></pre> <p>               Bases: <code>SensorReadingError</code></p> <p>Raised when a sensor reading operation times out.</p>"},{"location":"api/#pysquared.sensor_reading.error.SensorReadingUnknownError","title":"SensorReadingUnknownError","text":"<pre><code>SensorReadingUnknownError(message: str = 'An unknown error occurred during sensor reading.')\n</code></pre> <p>               Bases: <code>SensorReadingError</code></p> <p>Raised when an unknown error occurs during sensor reading.</p>"},{"location":"api/#pysquared.sensor_reading.error.SensorReadingValueError","title":"SensorReadingValueError","text":"<pre><code>SensorReadingValueError(message: str = 'Sensor reading returned an invalid value.')\n</code></pre> <p>               Bases: <code>SensorReadingError</code></p> <p>Raised when a sensor reading returns an invalid value.</p>"},{"location":"api/#pysquared.sensor_reading.light","title":"light","text":"<p>Light sensor reading.</p> <p>Classes:</p> <ul> <li> <code>Light</code>           \u2013            <p>Light sensor reading (non-unit-specific light levels).</p> </li> </ul>"},{"location":"api/#pysquared.sensor_reading.light.Light","title":"Light","text":"<pre><code>Light(value: float)\n</code></pre> <p>               Bases: <code>Reading</code></p> <p>Light sensor reading (non-unit-specific light levels).</p> <p>Parameters:</p> <p>Methods:</p> <ul> <li> <code>to_dict</code>             \u2013              <p>Convert reading to dictionary for JSON serialization.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>timestamp</code>           \u2013            <p>Get the timestamp of the reading.</p> </li> <li> <code>value</code>               (<code>float</code>)           \u2013            <p>Get the light level (non-unit-specific).</p> </li> </ul>"},{"location":"api/#pysquared.sensor_reading.light.Light(value)","title":"<code>value</code>","text":"(<code>float</code>)           \u2013            <p>The light level (non-unit-specific)</p>"},{"location":"api/#pysquared.sensor_reading.light.Light.timestamp","title":"timestamp  <code>property</code>","text":"<pre><code>timestamp\n</code></pre> <p>Get the timestamp of the reading.</p>"},{"location":"api/#pysquared.sensor_reading.light.Light.value","title":"value  <code>property</code>","text":"<pre><code>value: float\n</code></pre> <p>Get the light level (non-unit-specific).</p> <p>Returns:</p> <ul> <li> <code>float</code>           \u2013            <p>The light level (non-unit-specific).</p> </li> </ul>"},{"location":"api/#pysquared.sensor_reading.light.Light.to_dict","title":"to_dict","text":"<pre><code>to_dict() -&gt; dict\n</code></pre> <p>Convert reading to dictionary for JSON serialization.</p>"},{"location":"api/#pysquared.sensor_reading.lux","title":"lux","text":"<p>Lux sensor reading.</p> <p>Classes:</p> <ul> <li> <code>Lux</code>           \u2013            <p>Lux sensor reading in SI lux.</p> </li> </ul>"},{"location":"api/#pysquared.sensor_reading.lux.Lux","title":"Lux","text":"<pre><code>Lux(value: float)\n</code></pre> <p>               Bases: <code>Reading</code></p> <p>Lux sensor reading in SI lux.</p> <p>Parameters:</p> <p>Methods:</p> <ul> <li> <code>to_dict</code>             \u2013              <p>Convert reading to dictionary for JSON serialization.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>timestamp</code>           \u2013            <p>Get the timestamp of the reading.</p> </li> <li> <code>value</code>               (<code>float</code>)           \u2013            <p>Get the light level in SI lux.</p> </li> </ul>"},{"location":"api/#pysquared.sensor_reading.lux.Lux(value)","title":"<code>value</code>","text":"(<code>float</code>)           \u2013            <p>The light level in SI lux</p>"},{"location":"api/#pysquared.sensor_reading.lux.Lux.timestamp","title":"timestamp  <code>property</code>","text":"<pre><code>timestamp\n</code></pre> <p>Get the timestamp of the reading.</p>"},{"location":"api/#pysquared.sensor_reading.lux.Lux.value","title":"value  <code>property</code>","text":"<pre><code>value: float\n</code></pre> <p>Get the light level in SI lux.</p> <p>Returns:</p> <ul> <li> <code>float</code>           \u2013            <p>The light level in SI lux.</p> </li> </ul>"},{"location":"api/#pysquared.sensor_reading.lux.Lux.to_dict","title":"to_dict","text":"<pre><code>to_dict() -&gt; dict\n</code></pre> <p>Convert reading to dictionary for JSON serialization.</p>"},{"location":"api/#pysquared.sensor_reading.magnetic","title":"magnetic","text":"<p>Magnetic sensor reading.</p> <p>Classes:</p> <ul> <li> <code>Magnetic</code>           \u2013            <p>Magnetic sensor reading in micro-Tesla (uT).</p> </li> </ul>"},{"location":"api/#pysquared.sensor_reading.magnetic.Magnetic","title":"Magnetic","text":"<pre><code>Magnetic(x: float, y: float, z: float)\n</code></pre> <p>               Bases: <code>Reading</code></p> <p>Magnetic sensor reading in micro-Tesla (uT).</p> <p>Parameters:</p> <p>Methods:</p> <ul> <li> <code>to_dict</code>             \u2013              <p>Convert reading to dictionary for JSON serialization.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>timestamp</code>           \u2013            <p>Get the timestamp of the reading.</p> </li> <li> <code>value</code>               (<code>Tuple[float, float, float]</code>)           \u2013            <p>Magnetic field in x, y, z micro-Tesla (uT).</p> </li> </ul>"},{"location":"api/#pysquared.sensor_reading.magnetic.Magnetic(x)","title":"<code>x</code>","text":"(<code>float</code>)           \u2013            <p>The x magnetic field in micro-Tesla (uT)</p>"},{"location":"api/#pysquared.sensor_reading.magnetic.Magnetic(y)","title":"<code>y</code>","text":"(<code>float</code>)           \u2013            <p>The y magnetic field in micro-Tesla (uT)</p>"},{"location":"api/#pysquared.sensor_reading.magnetic.Magnetic(z)","title":"<code>z</code>","text":"(<code>float</code>)           \u2013            <p>The z magnetic field in micro-Tesla (uT)</p>"},{"location":"api/#pysquared.sensor_reading.magnetic.Magnetic.timestamp","title":"timestamp  <code>property</code>","text":"<pre><code>timestamp\n</code></pre> <p>Get the timestamp of the reading.</p>"},{"location":"api/#pysquared.sensor_reading.magnetic.Magnetic.value","title":"value  <code>property</code>","text":"<pre><code>value: Tuple[float, float, float]\n</code></pre> <p>Magnetic field in x, y, z micro-Tesla (uT).</p> <p>Returns:</p> <ul> <li> <code>Tuple[float, float, float]</code>           \u2013            <p>A tuple containing the x, y, and z components of the magnetic field.</p> </li> </ul>"},{"location":"api/#pysquared.sensor_reading.magnetic.Magnetic.to_dict","title":"to_dict","text":"<pre><code>to_dict() -&gt; dict\n</code></pre> <p>Convert reading to dictionary for JSON serialization.</p>"},{"location":"api/#pysquared.sensor_reading.temperature","title":"temperature","text":"<p>Temperature sensor reading.</p> <p>Classes:</p> <ul> <li> <code>Temperature</code>           \u2013            <p>Temperature sensor reading in degrees celsius.</p> </li> </ul>"},{"location":"api/#pysquared.sensor_reading.temperature.Temperature","title":"Temperature","text":"<pre><code>Temperature(value: float)\n</code></pre> <p>               Bases: <code>Reading</code></p> <p>Temperature sensor reading in degrees celsius.</p> <p>Parameters:</p> <p>Methods:</p> <ul> <li> <code>to_dict</code>             \u2013              <p>Convert reading to dictionary for JSON serialization.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>timestamp</code>           \u2013            <p>Get the timestamp of the reading.</p> </li> <li> <code>value</code>               (<code>float</code>)           \u2013            <p>Get the temperature value in degrees celsius.</p> </li> </ul>"},{"location":"api/#pysquared.sensor_reading.temperature.Temperature(value)","title":"<code>value</code>","text":"(<code>float</code>)           \u2013            <p>Temperature in degrees Celsius.</p>"},{"location":"api/#pysquared.sensor_reading.temperature.Temperature.timestamp","title":"timestamp  <code>property</code>","text":"<pre><code>timestamp\n</code></pre> <p>Get the timestamp of the reading.</p>"},{"location":"api/#pysquared.sensor_reading.temperature.Temperature.value","title":"value  <code>property</code>","text":"<pre><code>value: float\n</code></pre> <p>Get the temperature value in degrees celsius.</p> <p>Returns:</p> <ul> <li> <code>float</code>           \u2013            <p>The temperature in degrees Celsius.</p> </li> </ul>"},{"location":"api/#pysquared.sensor_reading.temperature.Temperature.to_dict","title":"to_dict","text":"<pre><code>to_dict() -&gt; dict\n</code></pre> <p>Convert reading to dictionary for JSON serialization.</p>"},{"location":"api/#pysquared.sensor_reading.voltage","title":"voltage","text":"<p>Voltage sensor reading.</p> <p>Classes:</p> <ul> <li> <code>Voltage</code>           \u2013            <p>Voltage sensor reading.</p> </li> </ul>"},{"location":"api/#pysquared.sensor_reading.voltage.Voltage","title":"Voltage","text":"<pre><code>Voltage(value: float)\n</code></pre> <p>               Bases: <code>Reading</code></p> <p>Voltage sensor reading.</p> <p>Parameters:</p> <p>Methods:</p> <ul> <li> <code>to_dict</code>             \u2013              <p>Convert reading to dictionary for JSON serialization.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>timestamp</code>           \u2013            <p>Get the timestamp of the reading.</p> </li> <li> <code>value</code>               (<code>float</code>)           \u2013            <p>Get the voltage value in volts (V).</p> </li> </ul>"},{"location":"api/#pysquared.sensor_reading.voltage.Voltage(value)","title":"<code>value</code>","text":"(<code>float</code>)           \u2013            <p>The voltage in volts (V)</p>"},{"location":"api/#pysquared.sensor_reading.voltage.Voltage.timestamp","title":"timestamp  <code>property</code>","text":"<pre><code>timestamp\n</code></pre> <p>Get the timestamp of the reading.</p>"},{"location":"api/#pysquared.sensor_reading.voltage.Voltage.value","title":"value  <code>property</code>","text":"<pre><code>value: float\n</code></pre> <p>Get the voltage value in volts (V).</p> <p>Returns:</p> <ul> <li> <code>float</code>           \u2013            <p>The voltage in volts (V).</p> </li> </ul>"},{"location":"api/#pysquared.sensor_reading.voltage.Voltage.to_dict","title":"to_dict","text":"<pre><code>to_dict() -&gt; dict\n</code></pre> <p>Convert reading to dictionary for JSON serialization.</p>"},{"location":"api/#pysquared.sleep_helper","title":"sleep_helper","text":"<p>This module provides the SleepHelper class for managing safe sleep and hibernation modes for the PySquared satellite. It ensures the satellite sleeps for specified durations while maintaining system safety and watchdog activity.</p> <p>Classes:</p> <ul> <li> <code>SleepHelper</code>           \u2013            <p>Class responsible for sleeping the Satellite to conserve power.</p> </li> </ul>"},{"location":"api/#pysquared.sleep_helper.SleepHelper","title":"SleepHelper","text":"<pre><code>SleepHelper(logger: Logger, config: Config, watchdog: Watchdog)\n</code></pre> <p>Class responsible for sleeping the Satellite to conserve power.</p> <p>Attributes:</p> <ul> <li> <code>logger</code>               (<code>Logger</code>)           \u2013            <p>Logger instance for logging events and errors.</p> </li> <li> <code>watchdog</code>               (<code>Watchdog</code>)           \u2013            <p>Watchdog instance for system safety.</p> </li> <li> <code>config</code>               (<code>Config</code>)           \u2013            <p>Configuration object.</p> </li> </ul> <p>Parameters:</p> <ul> <li> </li> <li> </li> <li> </li> </ul> <p>Methods:</p> <ul> <li> <code>safe_sleep</code>             \u2013              <p>Puts the Satellite to sleep for a specified duration, in seconds while still petting the watchdog at least every 15 seconds.</p> </li> </ul>"},{"location":"api/#pysquared.sleep_helper.SleepHelper(logger)","title":"<code>logger</code>","text":"(<code>Logger</code>)           \u2013            <p>Logger instance for logging events and errors.</p>"},{"location":"api/#pysquared.sleep_helper.SleepHelper(watchdog)","title":"<code>watchdog</code>","text":"(<code>Watchdog</code>)           \u2013            <p>Watchdog instance for system safety.</p>"},{"location":"api/#pysquared.sleep_helper.SleepHelper(config)","title":"<code>config</code>","text":"(<code>Config</code>)           \u2013            <p>Configuration object.</p>"},{"location":"api/#pysquared.sleep_helper.SleepHelper.safe_sleep","title":"safe_sleep","text":"<pre><code>safe_sleep(duration, watchdog_timeout=15) -&gt; None\n</code></pre> <p>Puts the Satellite to sleep for a specified duration, in seconds while still petting the watchdog at least every 15 seconds.</p> <p>Allows for a maximum sleep duration of the longest_allowable_sleep_time field specified in config</p> <p>Parameters:</p>"},{"location":"api/#pysquared.sleep_helper.SleepHelper.safe_sleep(duration)","title":"<code>duration</code>","text":"(<code>int</code>)           \u2013            <p>Specified time, in seconds, to sleep the Satellite for.</p>"},{"location":"api/#pysquared.sleep_helper.SleepHelper.safe_sleep(watchdog_timeout)","title":"<code>watchdog_timeout</code>","text":"(<code>int</code>, default:                   <code>15</code> )           \u2013            <p>Time, in seconds, to wait before petting the watchdog. Default is 15 seconds.</p>"},{"location":"api/#pysquared.watchdog","title":"watchdog","text":"<p>This module provides the Watchdog class for managing the hardware watchdog timer on the PySquared satellite. The watchdog helps ensure system reliability by requiring periodic \"petting\" to prevent system resets.</p> <p>Classes:</p> <ul> <li> <code>Watchdog</code>           \u2013            <p>Watchdog class for managing the hardware watchdog timer.</p> </li> </ul>"},{"location":"api/#pysquared.watchdog.Watchdog","title":"Watchdog","text":"<pre><code>Watchdog(logger: Logger, pin: Pin)\n</code></pre> <p>Watchdog class for managing the hardware watchdog timer.</p> <p>Attributes:</p> <ul> <li> <code>_log</code>               (<code>Logger</code>)           \u2013            <p>Logger instance for logging messages.</p> </li> <li> <code>_digital_in_out</code>               (<code>DigitalInOut</code>)           \u2013            <p>Digital output for controlling the watchdog pin.</p> </li> </ul> <p>Parameters:</p> <ul> <li> </li> <li> </li> </ul> <p>Raises:</p> <ul> <li> <code>HardwareInitializationError</code>             \u2013            <p>If the pin fails to initialize.</p> </li> </ul> <p>Methods:</p> <ul> <li> <code>pet</code>             \u2013              <p>Pets (resets) the watchdog timer to prevent system reset.</p> </li> </ul>"},{"location":"api/#pysquared.watchdog.Watchdog(logger)","title":"<code>logger</code>","text":"(<code>Logger</code>)           \u2013            <p>Logger instance for logging messages.</p>"},{"location":"api/#pysquared.watchdog.Watchdog(pin)","title":"<code>pin</code>","text":"(<code>Pin</code>)           \u2013            <p>Pin to use for the watchdog timer.</p>"},{"location":"api/#pysquared.watchdog.Watchdog.pet","title":"pet","text":"<pre><code>pet() -&gt; None\n</code></pre> <p>Pets (resets) the watchdog timer to prevent system reset.</p>"},{"location":"contributing/","title":"Contributing Guide","text":"<p>Welcome to the contributing guide for PySquared! This guide will help you set up your development environment and get you started with contributing to the repository.</p>"},{"location":"contributing/#setting-up-your-code-editor","title":"Setting up your code editor","text":""},{"location":"contributing/#workspaces","title":"Workspaces","text":"<p>Working with the PySquared repo is different from working with other Python repos because part of the repo is designed to run on CircuitPython (e.g. the flight software) while another part is designed to run on standard CPython (e.g. the tests and development tools). To make the development experience as smooth as possible, we use <code>uv</code> workspaces for python environment management, a CircuitPython specific <code>typeshed</code> to give developers accurate type information for CircuitPython code, and <code>pyright</code> configurations to control when the CircuitPython typeshed is loaded.</p> <p>To experience the best development environment, we recommend using a code editor that supports code workspaces such as VS Code. When you open up the PySquared repository in your editor, open the workspace file located at <code>pysquared.code-workspace</code> and click <code>Open Workspace</code>. This will reload VS Code into workspace mode.</p> <p></p> <p>When you're in workspace mode, your editor will be able to autocomplete and tell you if you have any type errors in your code for both CircuitPython and CPython.</p> <p></p> <p>Not using VS Code?</p> <p>If you're using a different code editor and you have configured it to provide this functionality, please consider contributing a section to this guide to help others get set up.</p>"},{"location":"contributing/#dev-containers","title":"Dev Containers","text":"<p>Every repository comes with a <code>.devcontainer</code> directory that contains configuration for a ready-to-use development environment. This environment includes all the necessary tools and dependencies to work on the repository. You can use any code editor that supports dev containers, such as Visual Studio Code, to open the repository in a dev container.</p>"},{"location":"contributing/#testing-custom-versions-of-pysquared","title":"Testing custom versions of PySquared","text":"<p>If you're making a change to PySquared, you can test it in a board specific repository by installing a specific version of PySquared.</p> <p>Start by pushing your PySquared changes to a branch in the pysquared repository. Then, you can install that version of PySquared in a board specific repository by running the following command:</p> <pre><code>PYSQUARED_VERSION=&lt;version_commit_or_branch_name&gt; make install-flight-software BOARD_MOUNT_POINT=&lt;board_mount_point&gt;\n</code></pre> <p>If you've forgotten how to find your board's mount point, the instructions are in the Getting Started Guide.</p>"},{"location":"contributing/#testing-documentation-changes","title":"Testing Documentation Changes","text":"<p>We use MkDocs to build our documentation. If you make changes to the documentation, you can build and test it locally by running:</p> <pre><code>make docs\n</code></pre> <p>This will generate the documentation and serve it locally. You can then open your web browser and navigate to <code>http://localhost:8000</code> to see the changes.</p>"},{"location":"contributing/#continuous-integration-ci","title":"Continuous Integration (CI)","text":"<p>This repo has a continuous integration system using Github Actions. Anytime you push code to the repo, it will run a series of tests. If you see a failure in the CI, you can click on the details to see what went wrong.</p>"},{"location":"contributing/#common-build-failures","title":"Common Build Failures","text":"<p>Here are some common build failures you might see and how to fix them:</p>"},{"location":"contributing/#lint-failure","title":"Lint Failure","text":"<p>Every time you make a change in git, it's called a commit. We have a tool called a pre-commit hook that will run before you make each commit to ensure your code is safe and formatted correctly. If you experience a lint failure you can run the following to fix it for you or tell you what's wrong. <pre><code>make fmt\n</code></pre></p>"},{"location":"contributing/#test-failure","title":"Test Failure","text":"<p>To ensure our code works as we expect we use automated testing. If you're seeing a testing failure in your build, you can see what's wrong by running those tests yourself with: <pre><code>make test\n</code></pre></p>"},{"location":"contributing/#type-checking-failure","title":"Type Checking Failure","text":"<p>We use a tool called pyright to check our code for type errors. An example of a type error is if you try to add a string and an integer together. Pyright will catch these errors before they cause problems in your code. If you see a type checking failure in your build, you can run the following command to see what the error is: <pre><code>make typecheck\n</code></pre></p>"},{"location":"design-guide/","title":"Design Guide","text":"<p>This document provides an overview of the design principles and architecture of the PySquared Flight Software. It is intended for developers who want to understand how the software is structured and how to contribute effectively.</p>"},{"location":"design-guide/#circuitpython","title":"CircuitPython","text":"<p>PySquared is built on top of CircuitPython, which is a version of Python designed for microcontrollers. CircuitPython is a fork of MicroPython which adhears to a subset of the Python language specification. Python 3.4 syntax is supported with some additional features pulled from later releases such as type hinting.</p>"},{"location":"design-guide/#resources","title":"Resources","text":"<ul> <li>Python 3.4 Reference</li> <li>Differences between MicroPython and Python</li> <li>Differences between CircuitPython and MicroPython</li> <li>CircuitPython Shared Bindings Documentation</li> <li>CircuitPython Standard Libraries Documentation</li> <li>CircuitPython Design Guide</li> </ul>"},{"location":"design-guide/#types-and-type-checking","title":"Types and Type Checking","text":"<p>We use type hints throughout the PySquared codebase to ensure that our code is clear and maintainable. Type hints help us catch errors early and make it easier to understand the expected types of variables and function parameters.</p> <p>We use typeshed stubs to provide more accurate type hints for CircuitPython, replacing the default Python standard library type hints. These CircuitPython-specific stubs are located in the <code>typeshed/</code> directory. This helps the typechecker catch compatibility issues with CircuitPython code before running it on a device.</p> <p>We do not accept changes to files in the <code>pysquared/</code> directory that include lines ignoring the type checker (e.g., <code># type: ignore</code>). The only exceptions are:</p> <ul> <li> <p>Upstream Fix in Progress: If a type error is caused by a bug or limitation in an external dependency, you may ignore the line only when leaving a comment with a link to the issue or PR where it is fixed or a fix is in progress. A valid type hint might look like this:</p> <pre><code>some_variable = some_function()  # type: ignore  # PR https://github.com/adafruit/circuitpython/pull/10603\n</code></pre> </li> </ul> <p>If you encounter a type error, first consider if it can be resolved by improving your code's design. If you believe an exception is necessary, please reach out for assistance before proceeding.</p> Using the Typing Module <p>For more advanced type hinting we can use the Python standard library's <code>typing</code> module which was introduced in Python 3.5. This module provides a variety of type hints that can be used to specify more complex types, such as <code>List</code>, <code>Dict</code>, and <code>Optional</code>. CircuitPython does not support the <code>typing</code> module so we must wrap the import in a try/except block to avoid import errors. For example:</p> <pre><code>try:\n    from typing import List, Dict, Optional\nexcept ImportError:\n    pass\n</code></pre> <p>This pattern allows us to use type hints in our code while still being compatible with CircuitPython.</p> <p>Additionally we cannot use <code>typing</code>'s <code>Any</code> type hint in CircuitPython. Instead, we can use <code>object</code> as a generic type hint.</p>"},{"location":"design-guide/#protocols","title":"Protocols","text":"<p>Protocols are a way to define a set of methods that a class must implement. They are similar to interfaces in other programming languages or header files in C. Protocols allow us to define a contract for classes to follow, ensuring that they implement the required methods. CircuitPython does not support Protocols, so we use base classes to define our protocols where all required methods are implemented with <code>...</code> (Ellipsis). All classes that implement the protocol must override these methods. Protocols can be found in <code>pysquared/protos/</code>.</p>"},{"location":"design-guide/#testing","title":"Testing","text":"<p>We use pytest for unit testing our code. We are designing software for spacecraft, so it is important that we have a robust testing framework to ensure our code is reliable and works as expected. We write tests for all of our code, and we run these tests automatically using GitHub Actions. We aim to have 100% test coverage for all of our code, which means that every line of code is tested by at least one test case.</p>"},{"location":"design-guide/#documentation","title":"Documentation","text":"<p>We use MkDocs to build our documentation. We write our documentation in Markdown, which is a lightweight markup language that is easy to read and write. We document our code using docstrings, which are special comments that describe the purpose and usage of a function or class. We also use type hints in our docstrings to provide additional information about the expected types of parameters and return values. Where it makes sense, add usage examples following CommonMark fenced code blocks to document how to use your code.</p>"},{"location":"design-guide/#module-documentation","title":"Module Documentation","text":"<p>Start with a brief summary, followed by an optional extended description:</p> <pre><code>\"\"\"This module provides utilities for parsing and validating telemetry data from spacecraft sensors.\n\nIt includes classes and functions for decoding sensor packets, verifying data integrity, and converting\nraw readings into SI units for further analysis.\n\"\"\"\n</code></pre>"},{"location":"design-guide/#class-documentation","title":"Class Documentation","text":"<p>Begin with a short description, a detailed explanation, and a practical usage example:</p> <pre><code>\"\"\"The TelemetryParser class extracts and validates sensor readings from raw telemetry packets.\n\nTelemetryParser handles packet decoding, error checking, and conversion to SI units. It is designed\nfor use in spacecraft flight software where reliable sensor data is critical.\n\n**Usage:**\n~~~python\nfrom pysquared.telemetry import TelemetryParser\n\nparser = TelemetryParser()\npacket = b'\\x01\\x02\\x03\\x04'\nreading = parser.parse(packet)\nprint(reading.timestamp, reading.acceleration)  # Output: 2024-06-01T12:00:00Z (0.0, 9.8, 0.0)\n~~~\n\"\"\"\n</code></pre>"},{"location":"design-guide/#functionmethod-documentation","title":"Function/Method Documentation","text":"<p>Include a description, argument details, return values, and any exceptions raised:</p> <pre><code>\"\"\"\nValidate a sensor reading and convert it to SI units.\n\nArgs:\n    reading: Raw sensor reading with keys 'value' and 'unit'.\n    sensor_type: Type of sensor (e.g., 'acceleration', 'temperature').\n\nReturns:\n    float: The validated reading in SI units.\n\nRaises:\n    KeyError: If required keys are missing from the reading.\n    ValueError: If the reading value is out of expected range.\n\"\"\"\n</code></pre>"},{"location":"design-guide/#sensor-readings","title":"Sensor Readings","text":"<p>All sensor readings must be in SI units and stored in a structure that includes the time of the reading. Including the time of the reading is important for analysing sensor data and ensuring that processes such as detumbling and attitude control can be performed accurately.</p> <p>The following table lists possible sensor properties, their corresponding types and units for common sensor readings. The table was pulled directly from the CircuitPython Design Guide:</p> Property Name Python Type Units / Description acceleration (float, float, float) x, y, z meter per second\u00b2 alarm (time.struct, str) Sample alarm time and frequency string CO2 float measured CO\u2082 in ppm color int RGB, eight bits per channel (0xff0000 is red) current float milliamps (mA) datetime time.struct date and time distance float centimeters (cm) duty_cycle int 16-bit PWM duty cycle eCO2 float equivalent/estimated CO\u2082 in ppm frequency int Hertz (Hz) angular velocity (float, float, float) x, y, z radians per second light float non-unit-specific light levels lux float SI lux magnetic (float, float, float) x, y, z micro-Tesla (uT) orientation (float, float, float) x, y, z degrees pressure float hectopascal (hPa) proximity int non-unit-specific proximity values relative_humidity float percent sound_level float non-unit-specific sound level temperature float degrees Celsius TVOC float Total Volatile Organic Compounds in ppb voltage float volts (V) weight float grams (g) <p>Definitions for sensor readings can be found in <code>pysquared/sensors/</code></p> <p>Handling Sensor Reading Failures</p> <p>Sensor reading failures must be expected and handled gracefully. If a sensor reading fails, the code should log an error message and return a default value (e.g., <code>0.0</code> for numeric readings or <code>None</code> for optional readings). This ensures that the system can continue to operate even if a sensor is temporarily unavailable. In the case of a sensor hanging, the attempt must time out and return a default value.</p>"},{"location":"design-guide/#resources_1","title":"Resources","text":"<ul> <li>Adafruit Unified Sensor Driver</li> <li>Android Motion Sensor Documentation</li> <li>Android Position Sensor Documentation</li> <li>Android Environment Sensor Documentation</li> </ul>"},{"location":"design-guide/#dependency-management","title":"Dependency Management","text":"<p>We use <code>uv</code> for managing our python development environment and dependencies. It allows us to define our dependencies in a <code>pyproject.toml</code> file and provides a consistent way to install and manage them across different environments. We use dependency groups to separate the dependencies needed for running on the satellite <code>pyproject.dependencies</code>, development <code>pyproject.dev</code>, and documentation <code>pyproject.docs</code>.</p> <p><code>uv</code> is downloaded and installed automatically when you use run <code>make</code> commands. Please see the Makefile or <code>make help</code> for more information on how to use <code>uv</code> to manage your development environment.</p>"},{"location":"design-guide/#linting-and-code-style","title":"Linting and Code Style","text":"<p>We use <code>ruff</code> for linting and formatting our code. <code>ruff</code> is a fast, extensible linter that checks our code for errors and enforces specific coding standards and style. We use <code>ruff</code>'s default configuration with only one addition, isort (<code>-I</code>), for linting and formatting our code.</p>"},{"location":"design-guide/#linting","title":"Linting","text":"<p><code>ruff</code> checks our code for errors following pyflakes logic.</p>"},{"location":"design-guide/#code-style","title":"Code Style","text":"<p>By default <code>ruff</code>, enforces the <code>black</code> style with a few deviations decided by <code>ruff</code> for formatting our code. Code formatting ensures that our code is consistent and easy to read.</p>"},{"location":"design-guide/#error-handling","title":"Error Handling","text":"<p>Error handling in PySquared is designed to be robust and predictable. We use standard <code>try...except</code> blocks to catch exceptions. When an exception is caught, it should be logged with the <code>logger.error()</code> or <code>logger.critical()</code> method. This ensures that we have a record of the error and can diagnose it later.</p> <pre><code>try:\n    # Code that may raise an exception\nexcept Exception as e:\n    logger.error(\"An error occurred\", err=e)\n</code></pre> <p>Custom exceptions should be used to represent specific error conditions in your code. This allows us to handle different types of errors in a more granular way. Custom exceptions should inherit from the built-in <code>Exception</code> class and should be named using the <code>Error</code> suffix.</p> <pre><code>class CustomError(Exception):\n    \"\"\"Custom exception for specific error conditions.\"\"\"\n    pass\n\ntry:\n    # Code that may raise a CustomError\nexcept CustomError as e:\n    logger.error(\"A custom error occurred\", err=e)\n</code></pre> <p>When raising exceptions, always provide a clear and descriptive error message. This will help us understand the context of the error when it is logged.</p> <pre><code>raise CustomError(\"This is a custom error message\")\n</code></pre>"},{"location":"design-guide/#logging","title":"Logging","text":"<p>The syntax for our logging module <code>logger</code> is based off the popular Python logger <code>Loguru</code>. We use the <code>logger</code> module to log messages at different levels (<code>debug</code>, <code>info</code>, <code>warning</code>, <code>error</code>, <code>critical</code>) throughout our code. This allows us to track the flow of execution and diagnose issues when they arise.</p> <p>Logs are structured as JSON, which makes them easy to parse and analyze. When logging, you can include additional key-value pairs to provide context.</p> <pre><code>logger.info(\"User logged in\", user_id=123)\n</code></pre> <p>Code that raises an exception should log at the <code>error</code> level. Code that failed but is recoverable should log at the <code>warning</code> level. The <code>debug</code> level should be used to understand the flow of the program during development and debugging. The <code>info</code> level should be used for general information about the program's execution, such as startup, shutdown, and other important updates. <code>critical</code> should be used for serious errors that may prevent the satellite from continuing operation, requiring a restart.</p>"},{"location":"design-guide/#configuration","title":"Configuration","text":"<p>Configuration management in PySquared is centralized in the <code>Config</code> class. This class is responsible for loading, validating, and providing access to all configuration settings, which are stored in a JSON file.</p>"},{"location":"design-guide/#loading-and-accessing-configuration","title":"Loading and Accessing Configuration","text":"<p>The <code>Config</code> class is initialized with the path to the configuration file. It parses the JSON and exposes the settings as attributes.</p> <p>Usage: <pre><code>from pysquared.config import Config\n\n# Initialize the config with the path to your settings file\nconfig = Config(\"config.json\")\n\n# Access configuration values directly\nprint(f\"Satellite Name: {config.cubesat_name}\")\nprint(f\"Sleep Duration: {config.sleep_duration} seconds\")\n</code></pre></p>"},{"location":"design-guide/#updating-configuration","title":"Updating Configuration","text":"<p>The <code>update_config</code> method allows for both temporary (in-memory) and permanent (persisted to the JSON file) changes to the configuration.</p> <ul> <li>Temporary Updates: Changes are only applied to the <code>Config</code> object in memory and will be lost on restart.</li> <li>Permanent Updates: Changes are written back to the configuration file.</li> </ul> <pre><code># Temporarily update the sleep duration\nconfig.update_config(\"sleep_duration\", 120, temporary=True)\n\n# Permanently update the satellite's name\nconfig.update_config(\"cubesat_name\", \"PyCubed\", temporary=False)\n</code></pre>"},{"location":"design-guide/#validation","title":"Validation","text":"<p>The <code>Config</code> class includes a validation schema to ensure that all configuration values are within expected ranges and of the correct type. Any attempt to set an invalid value will raise a <code>TypeError</code> or <code>ValueError</code>. This helps prevent runtime errors due to misconfiguration.</p>"},{"location":"design-guide/#radio-configuration","title":"Radio Configuration","text":"<p>Radio-specific settings are managed by the <code>RadioConfig</code> class, which is a nested object within the main <code>Config</code> class.</p>"},{"location":"design-guide/#imports","title":"Imports","text":"<p>We use relative imports for all of our modules. This allows us to easily import pysquared into downstream libraries like our board specific repos. For example, if we have a module <code>pysquared.sensors.temperature</code>, we can import it in another module using:</p> <pre><code>from .sensors.temperature import TemperatureSensor\n</code></pre>"},{"location":"design-guide/#non-volatile-memory-nvm","title":"Non-Volatile Memory (NVM)","text":"<p>We use the <code>pysquared.nvm</code> module to manage non-volatile memory (NVM) on the flight control board. This module provides a way to store persistent data across reboots, such as error counters and other important state information. The NVM module includes a <code>Counter</code> class for counting events and a <code>Flag</code> class for storing boolean flags.</p>"},{"location":"frozen-modules/","title":"Building Custom CircuitPython Firmware with Frozen Modules","text":""},{"location":"frozen-modules/#overview","title":"Overview","text":"<p>Frozen modules are Python libraries that are compiled directly into the CircuitPython firmware binary, rather than being stored as separate files on the CIRCUITPY filesystem. This approach provides several benefits:</p> <ul> <li>RAM Savings: Frozen modules execute directly from flash memory, freeing up precious RAM for your application code</li> <li>Flash Efficiency: Compiled frozen modules take less space than <code>.mpy</code> files on the filesystem</li> <li>Simplified Deployment: Single firmware file contains everything - no need to copy libraries to each board</li> <li>Faster Startup: Pre-compiled modules load faster than filesystem-based libraries</li> <li>Version Consistency: Ensures all boards run exactly the same library versions</li> </ul> <p>This is particularly valuable for resource-constrained boards like SAMD21 or when deploying to many satellites.</p>"},{"location":"frozen-modules/#when-to-use-frozen-modules","title":"When to Use Frozen Modules","text":"<p>Use frozen modules when: - You're deploying to many boards and want consistency - Your board is RAM-constrained (e.g., SAMD21 non-Express boards) - You want to prevent accidental library modifications on the board - You need faster startup times - You want to simplify your deployment process</p> <p>Use filesystem libraries when: - You need to update libraries without reflashing firmware - You're actively developing and testing new library versions - You want flexibility to mix and match library versions - Your board has plenty of RAM and flash</p>"},{"location":"frozen-modules/#prerequisites","title":"Prerequisites","text":"<p>Building custom CircuitPython firmware requires:</p> <ol> <li>Linux, macOS, or Windows with WSL: The build system requires a Unix-like environment</li> <li>Build Tools:</li> <li><code>gcc-arm-none-eabi</code> (ARM cross-compiler)</li> <li><code>git</code> (version control)</li> <li><code>python3</code> and <code>pip</code> (for build scripts)</li> <li><code>make</code> (build system)</li> <li>Disk Space: ~5GB for CircuitPython source and build artifacts</li> <li>Time: Initial build takes 10-30 minutes depending on your system</li> </ol>"},{"location":"frozen-modules/#build-process-overview","title":"Build Process Overview","text":"<p>The frozen module build process involves:</p> <ol> <li>Clone CircuitPython Source: Get the CircuitPython repository and all submodules</li> <li>Add PySquared Dependencies: Configure which libraries to freeze into firmware</li> <li>Configure Board: Specify board type and frozen module directories</li> <li>Build Firmware: Compile CircuitPython with frozen modules</li> <li>Flash Firmware: Upload the custom firmware to your board</li> </ol>"},{"location":"frozen-modules/#directory-structure","title":"Directory Structure","text":"<p>We recommend creating a <code>firmware/</code> directory in this repository to contain all firmware-related build artifacts:</p> <pre><code>pysquared/\n\u251c\u2500\u2500 firmware/                           # Frozen module build directory (new)\n\u2502   \u251c\u2500\u2500 circuitpython/                 # CircuitPython source (git submodule)\n\u2502   \u251c\u2500\u2500 frozen/                        # Directory for libraries to freeze\n\u2502   \u2502   \u251c\u2500\u2500 pysquared/                 # PySquared library (symlink or copy)\n\u2502   \u2502   \u2514\u2500\u2500 adafruit_circuitpython_*/  # Adafruit dependencies (git submodules)\n\u2502   \u251c\u2500\u2500 boards/                        # Custom board configurations\n\u2502   \u2502   \u251c\u2500\u2500 proves_rp2040_v4/\n\u2502   \u2502   \u251c\u2500\u2500 proves_rp2040_v5/\n\u2502   \u2502   \u251c\u2500\u2500 proves_rp2350_v5a/\n\u2502   \u2502   \u2514\u2500\u2500 proves_rp2350_v5b/\n\u2502   \u251c\u2500\u2500 Makefile                       # Build automation\n\u2502   \u251c\u2500\u2500 build-firmware.sh              # Build script\n\u2502   \u2514\u2500\u2500 README.md                      # Firmware-specific documentation\n\u251c\u2500\u2500 circuitpython-workspaces/          # Existing PySquared source\n\u2514\u2500\u2500 docs/                              # Documentation\n</code></pre>"},{"location":"frozen-modules/#step-by-step-build-instructions","title":"Step-by-Step Build Instructions","text":""},{"location":"frozen-modules/#1-set-up-build-environment","title":"1. Set Up Build Environment","text":""},{"location":"frozen-modules/#on-linux-ubuntudebian","title":"On Linux (Ubuntu/Debian):","text":"<pre><code>sudo apt update\nsudo apt install build-essential git python3 python3-pip gcc-arm-none-eabi\n</code></pre>"},{"location":"frozen-modules/#on-macos","title":"On macOS:","text":"<pre><code># Install Homebrew if not already installed\n/bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\"\n\n# Install ARM toolchain\nbrew install armmbed/formulae/arm-none-eabi-gcc\nbrew install python3 git\n</code></pre>"},{"location":"frozen-modules/#on-windows-wsl","title":"On Windows (WSL):","text":"<pre><code># First install WSL and Ubuntu from Microsoft Store, then:\nsudo apt update\nsudo apt install build-essential git python3 python3-pip gcc-arm-none-eabi\n</code></pre>"},{"location":"frozen-modules/#2-clone-circuitpython-source","title":"2. Clone CircuitPython Source","text":"<p>Navigate to the <code>firmware/</code> directory and clone CircuitPython:</p> <pre><code>cd firmware/\ngit clone https://github.com/adafruit/circuitpython.git\ncd circuitpython\ngit checkout &lt;stable-version-tag&gt;  # e.g., 9.0.5\npython3 tools/ci_fetch_deps.py raspberrypi\n# Return to firmware directory and use UV to install build dependencies\ncd ..\n# Ensure UV is available (installed by root Makefile)\ncd .. &amp;&amp; make uv &amp;&amp; cd firmware\n# Install in UV virtual environment\n../tools/uv-0.8.14/uv pip install -q -r circuitpython/requirements-dev.txt\n</code></pre> <p>Note: This fetches only submodules needed for RP2040/RP2350 (raspberrypi port), significantly reducing download size and time. To fetch all submodules (for other boards), use <code>make fetch-all-submodules</code> instead.</p> <p>Important: - Always use a tagged stable release, not the main branch, to ensure reproducible builds. - The <code>requirements-dev.txt</code> install provides Python tools needed for the build (cascadetoml, jinja2, typer, etc.). - Using <code>make setup</code> (recommended) automatically installs dependencies in the UV virtual environment, avoiding system Python conflicts.</p>"},{"location":"frozen-modules/#3-add-libraries-to-freeze","title":"3. Add Libraries to Freeze","text":"<p>You have two options for adding libraries:</p>"},{"location":"frozen-modules/#option-a-add-as-git-submodules-recommended-for-dependencies","title":"Option A: Add as Git Submodules (Recommended for Dependencies)","text":"<p>For each Adafruit library dependency in <code>circuitpython-workspaces/flight-software/pyproject.toml</code>:</p> <pre><code>cd firmware/circuitpython/frozen\ngit submodule add https://github.com/adafruit/Adafruit_CircuitPython_INA219\ncd Adafruit_CircuitPython_INA219\ngit checkout &lt;version-tag&gt;  # Match version in pyproject.toml\n</code></pre>"},{"location":"frozen-modules/#option-b-symlink-pysquared-library","title":"Option B: Symlink PySquared Library","text":"<p>For the PySquared library itself:</p> <pre><code>cd firmware/circuitpython/frozen\nln -s ../../../circuitpython-workspaces/flight-software/src/pysquared pysquared\n</code></pre> <p>This keeps the source in one place and avoids duplication.</p>"},{"location":"frozen-modules/#4-configure-board","title":"4. Configure Board","text":"<p>Create or modify the board configuration in <code>ports/raspberrypi/boards/&lt;BOARD_NAME&gt;/mpconfigboard.mk</code>:</p> <pre><code># Add PySquared and dependencies to frozen modules\nFROZEN_MPY_DIRS += $(TOP)/frozen/pysquared\nFROZEN_MPY_DIRS += $(TOP)/frozen/Adafruit_CircuitPython_INA219\nFROZEN_MPY_DIRS += $(TOP)/frozen/Adafruit_CircuitPython_LIS2MDL\n# ... add all other dependencies\n</code></pre>"},{"location":"frozen-modules/#5-build-firmware","title":"5. Build Firmware","text":"<p>Recommended: Use the firmware Makefile which ensures the correct Python environment:</p> <pre><code>cd firmware\nmake firmware BOARD=raspberry_pi_pico\n</code></pre> <p>Manual (advanced): If building directly in CircuitPython source:</p> <pre><code>cd firmware/circuitpython/ports/raspberrypi\n# Use UV to run make with the correct Python environment\n../../tools/uv-0.8.14/uv run --no-project make BOARD=&lt;board_name&gt;\n</code></pre> <p>For PROVES Kit boards (or use equivalent Raspberry Pi Pico boards): - <code>raspberry_pi_pico</code> (for v4, v5) - <code>raspberry_pi_pico_w</code> (with WiFi) - Custom PROVES board definitions (once configured)</p> <p>The build will create a <code>.uf2</code> file in <code>build-&lt;BOARD_NAME&gt;/firmware.uf2</code>.</p>"},{"location":"frozen-modules/#6-flash-firmware","title":"6. Flash Firmware","text":"<ol> <li>Put your board in bootloader mode (double-press RESET button)</li> <li>A USB drive named <code>RPI-RP2</code> or similar will appear</li> <li>Copy the <code>firmware.uf2</code> file to this drive</li> <li>The board will automatically reset and boot with the new firmware</li> </ol>"},{"location":"frozen-modules/#verifying-frozen-modules","title":"Verifying Frozen Modules","text":"<p>After flashing, connect to the board's serial console and run:</p> <pre><code>import sys\nprint(sys.modules)\n</code></pre> <p>Frozen modules will be listed and can be imported directly without being in <code>/lib</code>.</p> <p>Test that PySquared is frozen:</p> <pre><code>import pysquared\nprint(pysquared.__file__)  # Should show it's built-in, not from filesystem\n</code></pre>"},{"location":"frozen-modules/#automating-the-build","title":"Automating the Build","text":"<p>To make builds easier, create a <code>firmware/Makefile</code>:</p> <pre><code># Version pins\nCIRCUITPYTHON_VERSION ?= 9.0.5\nBOARD ?= proves_rp2040_v5\n\n.PHONY: all\nall: firmware\n\n.PHONY: setup\nsetup:\n    git clone https://github.com/adafruit/circuitpython.git || true\n    cd circuitpython &amp;&amp; git checkout $(CIRCUITPYTHON_VERSION)\n    cd circuitpython &amp;&amp; python3 tools/ci_fetch_deps.py raspberrypi\n    # Use UV for installing build dependencies (avoids system Python conflicts)\n    cd .. &amp;&amp; make uv &amp;&amp; cd firmware\n    ../tools/uv-0.8.14/uv pip install -q -r circuitpython/requirements-dev.txt\n    $(MAKE) add-dependencies\n\n.PHONY: add-dependencies\nadd-dependencies:\n    # Add each dependency from pyproject.toml as a submodule\n    # This would parse the pyproject.toml and add submodules automatically\n\n.PHONY: firmware\nfirmware:\n    cd circuitpython/ports/raspberrypi &amp;&amp; make BOARD=$(BOARD)\n    cp circuitpython/ports/raspberrypi/build-$(BOARD)/firmware.uf2 ./$(BOARD)-frozen-$(CIRCUITPYTHON_VERSION).uf2\n\n.PHONY: clean\nclean:\n    cd circuitpython/ports/raspberrypi &amp;&amp; make BOARD=$(BOARD) clean\n</code></pre> <p>Then build with: <pre><code>make BOARD=proves_rp2040_v5 firmware\n</code></pre></p>"},{"location":"frozen-modules/#updating-frozen-modules","title":"Updating Frozen Modules","text":"<p>When you update PySquared or dependencies:</p> <ol> <li>Update the library source code</li> <li>Rebuild the firmware: <code>make BOARD=&lt;board&gt; firmware</code></li> <li>Flash the new firmware to all boards</li> </ol> <p>There's no way to update frozen modules without rebuilding and reflashing the entire firmware.</p>"},{"location":"frozen-modules/#troubleshooting","title":"Troubleshooting","text":""},{"location":"frozen-modules/#build-fails-with-arm-none-eabi-gcc-command-not-found","title":"Build Fails with \"arm-none-eabi-gcc: command not found\"","text":"<p>Install the ARM toolchain for your platform (see prerequisites above).</p>"},{"location":"frozen-modules/#build-fails-with-missing-submodules","title":"Build Fails with Missing Submodules","text":"<p>For RP2040/RP2350 builds, run <code>python3 tools/ci_fetch_deps.py raspberrypi</code> in the circuitpython directory. For all ports, use <code>make fetch-all-submodules</code> instead.</p>"},{"location":"frozen-modules/#build-fails-with-python-import-errors-cascadetoml-jinja2-typer-etc","title":"Build Fails with Python Import Errors (cascadetoml, jinja2, typer, etc.)","text":"<p>First, ensure dependencies are installed: <code>make install-circuitpython-deps</code></p> <p>If the error persists during build, ensure you're using the Makefile to build: <code>make firmware BOARD=&lt;board&gt;</code>. This runs the build with UV's Python environment. Do NOT run <code>make</code> directly in the CircuitPython ports directory, as it won't have access to the installed packages.</p>"},{"location":"frozen-modules/#externally-managed-environment-error-on-macos","title":"\"externally-managed-environment\" Error on macOS","text":"<p>This occurs when trying to install packages system-wide. The Makefile now uses UV to install in a virtual environment. If you see this error, ensure you're using <code>make setup</code> or <code>make install-circuitpython-deps</code> rather than manual pip commands.</p>"},{"location":"frozen-modules/#firmware-file-is-too-large","title":"Firmware File is Too Large","text":"<ul> <li>Remove unused frozen modules from <code>mpconfigboard.mk</code></li> <li>Use <code>FROZEN_MPY_DIRS</code> instead of <code>FROZEN_PY_DIRS</code> (mpy is more compact)</li> <li>Consider building with optimizations: <code>make BOARD=&lt;board&gt; OPTIMIZATION=-O2</code></li> </ul>"},{"location":"frozen-modules/#board-wont-boot-after-flashing","title":"Board Won't Boot After Flashing","text":"<ul> <li>Verify you built for the correct board</li> <li>Try re-flashing the official CircuitPython firmware first</li> <li>Check the build log for errors</li> </ul>"},{"location":"frozen-modules/#module-not-found-after-freezing","title":"Module Not Found After Freezing","text":"<ul> <li>Verify the module directory is listed in <code>FROZEN_MPY_DIRS</code></li> <li>Check that the module has an <code>__init__.py</code></li> <li>Rebuild with <code>make clean</code> first to ensure fresh build</li> </ul>"},{"location":"frozen-modules/#cicd-integration","title":"CI/CD Integration","text":"<p>For automated builds in GitHub Actions, you can create a workflow that:</p> <ol> <li>Sets up the ARM toolchain</li> <li>Clones CircuitPython at a pinned version</li> <li>Adds dependencies as submodules</li> <li>Builds firmware for all PROVES boards</li> <li>Uploads firmware files as release artifacts</li> </ol> <p>Example <code>.github/workflows/build-firmware.yaml</code>:</p> <pre><code>name: Build Frozen Firmware\n\non:\n  push:\n    tags:\n      - 'v*'\n  workflow_dispatch:\n\njobs:\n  build-firmware:\n    runs-on: ubuntu-latest\n    strategy:\n      matrix:\n        board: [proves_rp2040_v4, proves_rp2040_v5, proves_rp2350_v5a, proves_rp2350_v5b]\n\n    steps:\n      - uses: actions/checkout@v4\n        with:\n          submodules: recursive\n\n      - name: Install ARM toolchain\n        run: |\n          sudo apt update\n          sudo apt install -y gcc-arm-none-eabi build-essential git python3 python3-pip\n\n      - name: Build firmware\n        run: |\n          cd firmware\n          make setup CIRCUITPYTHON_VERSION=9.0.5\n          make firmware BOARD=${{ matrix.board }}\n\n      - name: Upload firmware\n        uses: actions/upload-artifact@v4\n        with:\n          name: firmware-${{ matrix.board }}\n          path: firmware/${{ matrix.board }}-frozen-*.uf2\n</code></pre>"},{"location":"frozen-modules/#best-practices","title":"Best Practices","text":"<ol> <li>Pin Versions: Always use specific version tags for CircuitPython and libraries</li> <li>Document Dependencies: Keep a clear record of what's frozen and why</li> <li>Test Thoroughly: Test firmware on actual hardware before deploying to all boards</li> <li>Backup: Keep copies of working firmware files for rollback</li> <li>Version Firmware: Include version info in the firmware filename</li> <li>Automate: Use Makefiles or scripts to make builds reproducible</li> <li>CI/CD: Automate firmware builds for releases</li> </ol>"},{"location":"frozen-modules/#references","title":"References","text":"<ul> <li>CircuitPython Building Documentation</li> <li>Adafruit Guide: Adding Frozen Modules</li> <li>CircuitPython Frozen Libraries Overview</li> <li>CircuitPython GitHub Repository</li> </ul>"},{"location":"frozen-modules/#support","title":"Support","text":"<p>If you encounter issues building firmware:</p> <ol> <li>Check the CircuitPython Discord #help-with-circuitpython channel</li> <li>Open an issue in this repository with your build log</li> <li>Review the CircuitPython documentation for your specific board</li> </ol>"},{"location":"getting-started/","title":"Getting Started with PySquared","text":""},{"location":"getting-started/#introduction","title":"Introduction","text":"<p>PySquared is a flight software library designed for building and deploying satellite systems using CircuitPython. The library is hardware agnostic, meaning it can be used with various CircuitPython-compatible boards but is designed to run on PROVES hardware. Like the PROVES hardware, PySquared is an education first software project. We're here to help you learn to develop and launch satellites so be sure to ask questions!</p> <p>This guide will help you set up your development environment and get you started with building a satellite using the PySquared Flight Software.</p>"},{"location":"getting-started/#setting-up-your-computer","title":"Setting Up Your Computer","text":"<p>Set up your development environment by following the instructions in your OS specific guide.</p> Linux Guide <p>Update your package list and install the necessary packages: <pre><code>sudo apt update &amp;&amp; sudo apt install make screen zip\n</code></pre></p> MacOS Guide <ol> <li>Install Xcode Command Line Tools: These tools are necessary for compiling and building software.     <pre><code>xcode-select --install\n</code></pre></li> <li>Install Homebrew: Homebrew is a package manager for MacOS. Follow the instructions on brew.sh to install it.</li> <li>Install Required Packages: Open a terminal and run the following command to install required packages:     <pre><code>brew install screen\n</code></pre></li> </ol> Windows Guide <ol> <li>Install Git: Download and install the version control system Git. Make sure to also install the Git Bash terminal during the setup process.</li> <li>Install Putty: Download and install Putty.</li> <li>Install Chocolatey: Download and install the Windows package manager chocolatey.</li> <li>Install Required Packages: Open a command prompt or Git Bash terminal and run the following command to install required packages:     <pre><code>choco install make rsync zip\n</code></pre></li> </ol> <p>Keep in mind that the rest of this guide expects that you are using Git Bash.</p> WSL Guide <p>Follow the steps in the Linux Guide</p>"},{"location":"getting-started/#cloning-your-repository","title":"Cloning Your Repository","text":"<p>Let's start by creating your own repository to host your satellite's software. You can use one of the PySquared template repositories to get started quickly. Find your board version below, visit the repository, and click \"Fork\" to create your own copy of the repository.</p> Board Version Proves Repo v4 proveskit/CircuitPython_RP2040_v4 v5 proveskit/CircuitPython_RP2040_v5 v5a proveskit/CircuitPython_RP2350_v5a v5b proveskit/CircuitPython_RP2350_v5b <p>Then you can clone your repository to your local machine using the following command:</p> <pre><code>git clone https://github.com/your-username/your-repository.git\n</code></pre> Learn how to use the git command line <p></p> <p>Next, change directory (<code>cd</code>) into the repo directory:</p> <pre><code>cd your-repository\n</code></pre> <p>You are now in your repo directory. This is where you'll write code that makes its way onto your satellite!</p>"},{"location":"getting-started/#installing-circuitpython","title":"Installing CircuitPython","text":"CircuitPython May Already Be Installed <p>If you already have CircuitPython installed on your board, you can skip this section. You can check if CircuitPython is installed by plugging in your board and trying to access the serial console.</p> <p>Next, we need to install the latest CircuitPython firmware on your board. CircuitPython is a Python runtime for microcontrollers like the one on your board.</p> <p>First you must find your board's TTY port. You can find the TTY port by plugging in your board and running the following command:</p> <pre><code>make list-tty\n</code></pre> <p>Example output: <pre><code>TTY ports:\n/dev/cu.usbmodem3101\n</code></pre></p> <p>In this example, the TTY port is <code>/dev/cu.usbmodem3101</code>. This is the port you will use to communicate with your board.</p> Seeing more than one TTY port? <p>If you see more than one TTY port listed, you may need to unplug your board and run the command again to see which one is created when you plug it in. The new port is likely the one you want.</p> <p>Now you can install CircuitPython by running the following command:</p> <pre><code>make install-circuit-python BOARD_TTY_PORT=&lt;tty_port&gt;\n</code></pre>"},{"location":"getting-started/#installing-pysquared","title":"Installing PySquared","text":""},{"location":"getting-started/#finding-your-boards-mount-point","title":"Finding Your Board's Mount Point","text":"<p>Next, make sure your PROVES flight control board is plugged in and we'll find its mount point. The mount point is the location on your computer where the board's filesystem is accessible. This varies by operating system, so follow the guide for your OS below to find it.</p> Linux Guide <p>On linux you can use the <code>findmnt</code> command to locate your board's mount point. <pre><code>findmnt\n...\n\u251c\u2500/media/username/SOME-VALUE /dev/sdb1 vfat rw,nosuid,nodev,relatime 0 0\n</code></pre></p> <p>In this example, the mount point is <code>/dev/sdb1</code>. Another common mount point for linux systems is <code>/media/username/&lt;board_name&gt;</code>.</p> MacOS Guide <p>On Mac, you can find the location of your mount by looking for a mount named <code>PYSQUARED</code>, <code>PROVESKIT</code> or <code>CIRCUITPYTHON</code> in your <code>/Volumes</code> directory <pre><code>ls -lah /Volumes\n...\ndrwx------@  1 nate  staff    16K Jan  9 08:09 PYSQUARED/\n</code></pre></p> <p>In this example, the mount point is <code>/Volumes/PYSQUARED/</code>.</p> Windows Guide <p>In Git Bash your mount point will be the letter of the drive location in windows. For example, if the board is mounted at <code>D:\\</code> then your drive location for commands in Git Bash will be <code>/d/</code>.</p> WSL Guide <p>First you must follow the guides to connect and mount your board in WSL.</p> <p>After following those guides, your mount point will probably be the letter of the drive location in Windows with <code>/mnt/</code> prepended. For example, if the board is mounted at <code>D:\\</code> then your mount point in WSL will likely be <code>/mnt/d/</code>. If you are unsure, you can check the available mount points by running <code>ls /mnt/</code> in your terminal.</p>"},{"location":"getting-started/#running-the-install-command","title":"Running the Install Command","text":"<p>With the repository cloned and your boards mount point in hand you can now install the flight software to the board. Navigate to the root of your board specific repository and run:</p> <p><pre><code>make install-flight-software BOARD_MOUNT_POINT=&lt;path_to_your_board&gt;\n</code></pre> Replace <code>&lt;path_to_your_board&gt;</code> with the mount point discovered in the previous section.</p>"},{"location":"getting-started/#accessing-the-serial-console","title":"Accessing the Serial Console","text":"<p>To see streaming logs and use the on-board repl you must access the Circuit Python serial console.</p> <p>Remember the TTY port you found earlier? You will use that to connect to the board's serial console. The serial console allows you to interact with the board and see output from your code. If you don't remember the TTY port, you can run the <code>make list-tty</code> command again to find it.</p> Linux &amp; MacOS Guide <p>You can then connect to the board using the <code>screen</code> command: <pre><code>screen /dev/cu.usbmodem3101\n</code></pre></p> <p>For more information visit the Circuit Python Serial Console documentation.</p> Windows Guide <p>For information on how to access the serial console, visit the Circuit Python Serial Console documentation.</p> <p>Warning</p> <p>If all you see is a blank screen when you connect to the serial console, try pressing <code>CTRL+C</code> to see if you can get a prompt. If that doesn't work, try pressing <code>CTRL+D</code> to reset the board.</p>"},{"location":"getting-started/#congratulations","title":"Congratulations!","text":"<p>You have successfully installed PySquared and have started a serial console session to view the output from your flight control board! Now you can start your journey of building and launching satellites using CircuitPython and PySquared.</p>"},{"location":"getting-started/#next-steps","title":"Next Steps","text":"<p>Now that you have your development environment set up, you can start exploring the PySquared library and building on the repo you forked and cloned earlier in this guide.</p> <p>Here are some additional resources to help you get started:</p> <ul> <li>Are you interested in contributing to PySquared? Check out our Contributing Guide.</li> <li>Learn more about PROVES hardware with the PROVES Kit documentation.</li> <li>Learn more about CircuitPython with the Welcome to CircuitPython guide.</li> </ul>"},{"location":"license/","title":"License","text":"<pre><code>MIT License\n\nCopyright (c) 2024 Michael Pham and Nicole Maggard\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n</code></pre>"},{"location":"load_switch/","title":"Load Switch Manager","text":"<p>The Load Switch Manager provides a consistent interface for controlling load switches on PySquared satellite hardware. Load switches are used to control power to various subsystems and components.</p>"},{"location":"load_switch/#overview","title":"Overview","text":"<p>The <code>LoadSwitchManager</code> class implements the <code>LoadSwitchProto</code> interface and provides:</p> <ul> <li>Individual switch control (turn on/off specific switches)</li> <li>Bulk operations (turn all switches on/off)</li> <li>State tracking (public dictionary of switch states)</li> <li>Dynamic switch management (add/remove switches at runtime)</li> <li>Custom naming for each load switch</li> <li>Configurable enable logic (active high/low)</li> </ul>"},{"location":"load_switch/#usage","title":"Usage","text":""},{"location":"load_switch/#basic-setup","title":"Basic Setup","text":"<pre><code>from lib.pysquared.hardware.load_switch.manager.load_switch import LoadSwitchManager\nfrom digitalio import DigitalInOut\nimport board\n\n# Define your load switches with custom names\nload_switches = {\n    \"radio\": DigitalInOut(board.RADIO_ENABLE),\n    \"imu\": DigitalInOut(board.IMU_ENABLE),\n    \"magnetometer\": DigitalInOut(board.MAG_ENABLE),\n    \"camera\": DigitalInOut(board.CAMERA_ENABLE),\n}\n\n# Initialize the manager\nload_switch_manager = LoadSwitchManager(logger, load_switches, enable_logic=True)\n</code></pre>"},{"location":"load_switch/#individual-switch-control","title":"Individual Switch Control","text":"<pre><code># Turn on a specific switch\nsuccess = load_switch_manager.turn_on(\"radio\")\nif success:\n    print(\"Radio turned on successfully\")\n\n# Turn off a specific switch\nsuccess = load_switch_manager.turn_off(\"camera\")\nif success:\n    print(\"Camera turned off successfully\")\n</code></pre>"},{"location":"load_switch/#bulk-operations","title":"Bulk Operations","text":"<pre><code># Turn all switches on\nsuccess = load_switch_manager.turn_all_on()\nif success:\n    print(\"All switches turned on\")\n\n# Turn all switches off\nsuccess = load_switch_manager.turn_all_off()\nif success:\n    print(\"All switches turned off\")\n</code></pre>"},{"location":"load_switch/#state-monitoring","title":"State Monitoring","text":"<pre><code># Check individual switch state\nradio_state = load_switch_manager.get_switch_state(\"radio\")\nif radio_state is True:\n    print(\"Radio is on\")\nelif radio_state is False:\n    print(\"Radio is off\")\nelse:\n    print(\"Radio switch not found\")\n\n# Get all switch states\nall_states = load_switch_manager.get_all_states()\nprint(f\"All switch states: {all_states}\")\n\n# Access the public state dictionary directly\nprint(f\"Radio state: {load_switch_manager.switch_states['radio']}\")\n</code></pre>"},{"location":"load_switch/#dynamic-switch-management","title":"Dynamic Switch Management","text":"<pre><code># Add a new switch at runtime\nnew_switch = DigitalInOut(board.NEW_DEVICE_ENABLE)\nsuccess = load_switch_manager.add_switch(\"new_device\", new_switch)\nif success:\n    print(\"New switch added successfully\")\n\n# Remove a switch\nsuccess = load_switch_manager.remove_switch(\"camera\")\nif success:\n    print(\"Camera switch removed\")\n\n# Get list of all switch names\nswitch_names = load_switch_manager.get_switch_names()\nprint(f\"Available switches: {switch_names}\")\n</code></pre>"},{"location":"load_switch/#configuration","title":"Configuration","text":""},{"location":"load_switch/#enable-logic","title":"Enable Logic","text":"<p>The <code>enable_logic</code> parameter determines whether switches are activated with a high or low signal:</p> <pre><code># Active high (default) - switches turn on when pin is HIGH\nmanager_high = LoadSwitchManager(logger, switches, enable_logic=True)\n\n# Active low - switches turn on when pin is LOW\nmanager_low = LoadSwitchManager(logger, switches, enable_logic=False)\n</code></pre>"},{"location":"load_switch/#error-handling","title":"Error Handling","text":"<p>The LoadSwitchManager includes comprehensive error handling:</p> <ul> <li>Invalid switch names return <code>False</code> for operations</li> <li>Hardware errors are logged and return <code>False</code></li> <li>Initialization errors raise <code>HardwareInitializationError</code></li> <li>All operations are logged for debugging</li> </ul>"},{"location":"load_switch/#interface-methods","title":"Interface Methods","text":""},{"location":"load_switch/#required-methods-loadswitchproto","title":"Required Methods (LoadSwitchProto)","text":"<ul> <li><code>turn_on(switch_name: str) -&gt; bool</code></li> <li><code>turn_off(switch_name: str) -&gt; bool</code></li> <li><code>turn_all_on() -&gt; bool</code></li> <li><code>turn_all_off() -&gt; bool</code></li> <li><code>get_switch_state(switch_name: str) -&gt; bool | None</code></li> <li><code>get_all_states() -&gt; Dict[str, bool]</code></li> </ul>"},{"location":"load_switch/#additional-methods","title":"Additional Methods","text":"<ul> <li><code>add_switch(switch_name: str, switch_pin: DigitalInOut) -&gt; bool</code></li> <li><code>remove_switch(switch_name: str) -&gt; bool</code></li> <li><code>get_switch_names() -&gt; list[str]</code></li> </ul>"},{"location":"load_switch/#properties","title":"Properties","text":"<ul> <li><code>switch_states: Dict[str, bool]</code> - Public dictionary tracking all switch states</li> </ul>"},{"location":"load_switch/#dependencies","title":"Dependencies","text":"<ul> <li><code>digitalio.DigitalInOut</code> - For pin control</li> <li><code>pysquared.logger.Logger</code> - For logging</li> <li><code>pysquared.protos.load_switch.LoadSwitchProto</code> - Interface definition</li> <li><code>pysquared.hardware.decorators.with_retries</code> - For retry logic</li> <li><code>pysquared.hardware.exception.HardwareInitializationError</code> - For error handling</li> </ul>"},{"location":"radio-test/","title":"PySquared Radio Test Documentation","text":"<p>When receiving a PROVES device, most teams want to set up a radio test to ensure that the radio is functioning correctly. This document provides a guide on how to set up and run a radio test using the PySquared framework. You will need two boards for this test: one to send data and one to receive data.</p> <p>Radio License Required</p> <p>Before running the radio test, ensure that you have the appropriate license to operate the radio frequencies used by the PROVES Kit. Failure to comply with local regulations may result in interference with other devices or legal issues.</p>"},{"location":"radio-test/#setting-up-the-radio-test","title":"Setting Up the Radio Test","text":"<p>Just like in the Getting Started Guide, you will need to clone your board specific repository and make sure that CircuitPython is installed on both boards.</p>"},{"location":"radio-test/#setting-up-the-configuration","title":"Setting Up the Configuration","text":"<p>In the root of your board specific repository, you will find a <code>config.json</code>. Change the <code>radio.license</code> to your callsign or the callsign of the licensed individual you are operating under. This is important for compliance with radio regulations.</p> <pre><code>{\n  \"radio\": {\n    \"license\": \"YOUR_CALLSIGN\"\n  }\n}\n</code></pre> <p>Next, you will need to install the flight control software on one board and the ground station software on the other. To do this, you'll need to know your board's mount point.</p>"},{"location":"radio-test/#flight-control-software-installation","title":"Flight Control Software Installation","text":"<p>On the first board, install the flight control software by running the following command:</p> <pre><code>make install-flight-software BOARD_MOUNT_POINT=&lt;path_to_your_board&gt;\n</code></pre>"},{"location":"radio-test/#ground-station-software-installation","title":"Ground Station Software Installation","text":"<p>On the second board, install the ground station software by running the following command:</p> <pre><code>make install-ground-station BOARD_MOUNT_POINT=&lt;path_to_your_board&gt;\n</code></pre>"},{"location":"radio-test/#running-the-radio-test","title":"Running the Radio Test","text":"<p>Now, open the serial console for both boards. On the ground station board, use the console to send or receive messages to verify communication with the flight control board.</p>"}]}